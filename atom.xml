<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Guest997</title>
  
  <subtitle>一个在互联网下的小小 Coder</subtitle>
  <link href="http://guest997.tk/atom.xml" rel="self"/>
  
  <link href="http://guest997.tk/"/>
  <updated>2021-10-04T04:13:25.531Z</updated>
  <id>http://guest997.tk/</id>
  
  <author>
    <name>Guest997</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 详解(四)</title>
    <link href="http://guest997.tk/2021/09/30/redis-expound04/"/>
    <id>http://guest997.tk/2021/09/30/redis-expound04/</id>
    <published>2021-09-30T01:33:12.000Z</published>
    <updated>2021-10-04T04:13:25.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Geospatial（地理空间）"><a href="#Geospatial（地理空间）" class="headerlink" title="Geospatial（地理空间）"></a>Geospatial（地理空间）</h2><p><strong>Geospatial 底层的实现原理其实就是 Zset。我们可以使用 Zset 命令来操作 Geospatial。</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">geoadd 键 经度<span class="number">1</span> 纬度<span class="number">1</span> 元素名<span class="number">1</span> [经度<span class="number">2</span> 纬度<span class="number">2</span> 元素名<span class="number">2</span> ...]        <span class="comment">#添加一个或多个地理位置元素到键中</span></span><br><span class="line">geopos 键 元素名<span class="number">1</span> [元素名<span class="number">2</span> ...]                   <span class="comment">#获取一个或多个元素的坐标值</span></span><br><span class="line">geodist 键 元素名<span class="number">1</span> 元素名<span class="number">2</span> [m<span class="regexp">/km/mi</span><span class="regexp">/ft]        #获取两个元素之前的距离，默认使用米做单位（米/</span>千米<span class="regexp">/英里/</span>英尺）</span><br><span class="line"></span><br><span class="line">georadius 键 经度 纬度 数值 m<span class="regexp">/km/mi</span>/ft [withdist] [withcoord] [count 数值]              <span class="comment">#以给定的经纬度为中心，找出指定数值半径内的其它元素。（withdist：中心距离 withcoord：其它元素定位信息 count：筛选出指定的数量）</span></span><br><span class="line">georadiusbymember 键 元素名 数值 m<span class="regexp">/km/mi</span>/ft [withdist] [withcoord] [count 数值]         <span class="comment">#以给定的元素位置为中心，找出指定数值半径内的所有元素（包括中心元素）</span></span><br><span class="line">geohash 键 元素名<span class="number">1</span> [元素名<span class="number">2</span> ...]        <span class="comment">#将会返回11个字符的 geohash 字符串。如果两个字符串越像，则距离越近。</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound04.md-0.png"></p><p><img data-src="/images/redis-expound04.md-1.png"></p><h2 id="Hyperloglog（基数统计）"><a href="#Hyperloglog（基数统计）" class="headerlink" title="Hyperloglog（基数统计）"></a>Hyperloglog（基数统计）</h2><p>优点：占用的内存是固定的，可以存放2^64个不同的元素，即只需要使用12 KB 内存。</p><p><strong>什么是基数？</strong></p><p>数据集：{1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为：{1, 3, 5 ,7, 8}，基数（不重复元素）为5。基数估计就是在误差可接受的范围内，快速计算基数。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pfadd 键 元素1 [元素2 元素3 <span class="string">...</span>]        <span class="comment">#添加一个或多个元素到键中</span></span><br><span class="line">pfcount 键            <span class="comment">#统计键的基数</span></span><br><span class="line">pfmerge 新键 键1 键2 [键3 <span class="string">...</span>]          <span class="comment">#合并两个或多个键为新键</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound04.md-2.png"></p><h3 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h3><p>可用于统计网站的 UV （一个人访问一个网站多次，但是还是算作一个人）</p><h2 id="Bitmaps（位图）"><a href="#Bitmaps（位图）" class="headerlink" title="Bitmaps（位图）"></a>Bitmaps（位图）</h2><p>通过操作二进制位数来进行记录，就只有0和1两个状态。由于不好直接进行语法描述，我就直接在下面以打卡为例进行描述。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">setbit</span> sign <span class="number">0</span> <span class="number">1</span>        #sign 是键，<span class="number">0</span>表示周一，<span class="number">1</span>表示已打卡。依此类推。注意：第一个数值只能大于<span class="number">0</span>，第二个数值只能是<span class="number">0</span>或<span class="number">1</span>。</span><br><span class="line"><span class="attribute">getbit</span> sign <span class="number">2</span>          #sign 是键，<span class="number">2</span>表示周三。</span><br><span class="line"><span class="attribute">bitcount</span> sign          #sign 是键。表示获取设置为 <span class="number">1</span> 的位的数量，即一周打卡次数。</span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound04.md-3.png"></p><h3 id="备注：-1"><a href="#备注：-1" class="headerlink" title="备注："></a>备注：</h3><p>可用于统计用户信息。活跃、登录和打卡等，这些具有两个状态的信息，都可以使用 Bitmaps。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Geospatial（地理空间）&quot;&gt;&lt;a href=&quot;#Geospatial（地理空间）&quot; class=&quot;headerlink&quot; title=&quot;Geospatial（地理空间）&quot;&gt;&lt;/a&gt;Geospatial（地理空间）&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Geospatial 底层的实现原理其实就是 Zset。我们可以使用 Zset 命令来操作 Geospatial。&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;geoadd 键 经度&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 纬度&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 元素名&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; [经度&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 纬度&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 元素名&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; ...]        &lt;span class=&quot;comment&quot;&gt;#添加一个或多个地理位置元素到键中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;geopos 键 元素名&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; [元素名&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; ...]                   &lt;span class=&quot;comment&quot;&gt;#获取一个或多个元素的坐标值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;geodist 键 元素名&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 元素名&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; [m&lt;span class=&quot;regexp&quot;&gt;/km/mi&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ft]        #获取两个元素之前的距离，默认使用米做单位（米/&lt;/span&gt;千米&lt;span class=&quot;regexp&quot;&gt;/英里/&lt;/span&gt;英尺）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;georadius 键 经度 纬度 数值 m&lt;span class=&quot;regexp&quot;&gt;/km/mi&lt;/span&gt;/ft [withdist] [withcoord] [count 数值]              &lt;span class=&quot;comment&quot;&gt;#以给定的经纬度为中心，找出指定数值半径内的其它元素。（withdist：中心距离 withcoord：其它元素定位信息 count：筛选出指定的数量）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;georadiusbymember 键 元素名 数值 m&lt;span class=&quot;regexp&quot;&gt;/km/mi&lt;/span&gt;/ft [withdist] [withcoord] [count 数值]         &lt;span class=&quot;comment&quot;&gt;#以给定的元素位置为中心，找出指定数值半径内的所有元素（包括中心元素）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;geohash 键 元素名&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; [元素名&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; ...]        &lt;span class=&quot;comment&quot;&gt;#将会返回11个字符的 geohash 字符串。如果两个字符串越像，则距离越近。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img data-src=&quot;/images/redis-expound04.md-0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/redis-expound04.md-1.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="redis" scheme="http://guest997.tk/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 详解(三)</title>
    <link href="http://guest997.tk/2021/09/29/redis-expound03/"/>
    <id>http://guest997.tk/2021/09/29/redis-expound03/</id>
    <published>2021-09-29T02:54:27.000Z</published>
    <updated>2021-10-04T04:13:15.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Key-Value（键值对）"><a href="#Key-Value（键值对）" class="headerlink" title="Key-Value（键值对）"></a>Key-Value（键值对）</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> 键 值        <span class="comment">#设置键值对（能够直接覆盖存在键的值）</span></span><br><span class="line"><span class="built_in">get</span> 键        <span class="comment">#获取键相应的值</span></span><br><span class="line"><span class="built_in">keys</span> *         <span class="comment">#查看所有键</span></span><br><span class="line">exists 键    <span class="comment">#判断键是否存在</span></span><br><span class="line">move 数据库    <span class="comment">#移动键到别的数据库</span></span><br><span class="line">expire 键 秒数    <span class="comment">#设置键的过期时间</span></span><br><span class="line">ttl 键        <span class="comment">#查看键剩余时间</span></span><br><span class="line">type 键        <span class="comment">#查看键类型</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound03.md-0.png"></p><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">append 键 字符串  <span class="comment">#追加字符串，如果当前 key 不存在，就相当于设置键值对。</span></span><br><span class="line">strlen 键        <span class="comment">#获取字符串长度</span></span><br><span class="line">incr 键            <span class="comment">#值加一</span></span><br><span class="line">decr 键            <span class="comment">#值减一</span></span><br><span class="line">incrby 键 步长       <span class="comment">#指定值增量</span></span><br><span class="line">decrby 键 步长       <span class="comment">#指定值减量</span></span><br><span class="line"></span><br><span class="line">getrange 键 数值1 数值2     <span class="comment">#闭区间截取字符串。当数值2为-1时，表示从数值1的下标开始截取到最后一个值。</span></span><br><span class="line">setrange 键 数值 字符串    <span class="comment">#替换为指定位置开始的字符串</span></span><br><span class="line">setex 键 秒数 值   <span class="comment">#设置键值对，并会在指定秒数后过期。（set with expire）</span></span><br><span class="line">setnx 键 值        <span class="comment">#如果键不存在就创建（分布式锁中经常使用）(set if not exist)</span></span><br><span class="line"></span><br><span class="line">mset 键1 值1 [键2 值2 <span class="string">...</span>]   <span class="comment">#设置一个或多个键值对（能够直接覆盖存在键的值）</span></span><br><span class="line">mget 键1 键2 [键3 <span class="string">...</span>]         <span class="comment">#获取一个或多个键相应的值</span></span><br><span class="line">msetnx 键1 值1 [键2 值2 <span class="string">...</span>]        <span class="comment">#如果不存在就创建键值对。但是其具有原子性，就是其中一个键存在，其它键就都不会被创建。</span></span><br><span class="line">getset 键 值        <span class="comment">#先获取键相应的值，再设置键相应的值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对象创建的两种方式</span></span><br><span class="line"><span class="keyword">set</span> user<span class="function">:1</span> &#123;name<span class="function">:guest997</span>,age<span class="function">:18</span>&#125;  <span class="comment">#设置键为 user:1，值为 json 字符。</span></span><br><span class="line">mset user<span class="function">:1</span><span class="function">:name</span> guest997 user<span class="function">:1</span><span class="function">:age</span> 18      <span class="comment">#设置两个键分别为 user:1:name 和 user:1:age，值分别为 guest997 和 18。</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound03.md-1.png"></p><p><img data-src="/images/redis-expound03.md-2.png"></p><p><img data-src="/images/redis-expound03.md-3.png"></p><p><img data-src="/images/redis-expound03.md-4.png"></p><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>在 Redis 里，可以把 list 玩成栈、队列或阻塞队列。其中的元素是有序可重复的。为了方便理解，画个图。<img data-src="/images/redis-expound03.md-5.png"></p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lpush 列表名 值<span class="number">1</span> [值<span class="number">2</span> ...]      #将一个或者多个值插入到列表头部（左），当又有别的值插入时，之前的值就会往右移动。</span><br><span class="line"><span class="keyword">lrange</span> 列表名 数值<span class="number">1</span> 数值<span class="number">2</span>        #闭区间截取列表值。当数值<span class="number">2</span>为<span class="number">-1</span>时，表示从数值<span class="number">1</span>的下标开始截取到最后一个元素。</span><br><span class="line">rpush 列表名 值<span class="number">1</span> [值<span class="number">2</span> ...]      #将一个或者多个值插入到列表尾部（右），当又有别的值插入时，之前的值就会往左移动。</span><br><span class="line">lpop 列表名          #移除列表中的头部元素（左）</span><br><span class="line">rpop 列表名        #移除列表中的尾部元素（右）</span><br><span class="line"></span><br><span class="line"><span class="keyword">lindex</span> 列表名 下标  #通过下标获取列表中的值</span><br><span class="line">llen 列表名        #获取列表长度</span><br><span class="line">lrem 列表名 数值 指定元素       #移除列表中一个或多个指定元素</span><br><span class="line"></span><br><span class="line">ltrim 列表名 数值<span class="number">1</span> 数值<span class="number">2</span>        #闭区间修剪列表值。当数值<span class="number">2</span>为<span class="number">-1</span>时，表示从数值<span class="number">1</span>的下标开始修剪到最后一个元素。</span><br><span class="line">rpoplpush 列表名<span class="number">1</span> 列表名<span class="number">2</span>       #移动列表<span class="number">1</span>中的尾部元素（右）到列表<span class="number">2</span>中的头部（左）</span><br><span class="line"></span><br><span class="line">lest 列表名 下标 新值            #将列表中指定下标的值替换为新值</span><br><span class="line"><span class="keyword">linsert</span> 列表名 before/<span class="keyword">after</span> 值<span class="number">1</span> 值<span class="number">2</span>    #将值<span class="number">2</span>插入到值<span class="number">1</span>的前面或后面</span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound03.md-6.png"></p><p><img data-src="/images/redis-expound03.md-7.png"></p><p><img data-src="/images/redis-expound03.md-8.png"></p><p><img data-src="/images/redis-expound03.md-9.png"></p><h3 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h3><p>Redis 的 List 实际上是一个链表。如果移除了所有元素，即为空链表，就代表列表不存在。</p><p>在列表两边操作元素，效率是最高的，操作中间元素，相对来说效率会低一点。</p><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>其中的元素是无序不可重复的。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sadd 集合名 值1 [值2 <span class="string">...</span>]    <span class="comment">#将一个或多个值添加到集合中</span></span><br><span class="line">smembers 集合名     <span class="comment">#查看集合中的所有值</span></span><br><span class="line">sismember 集合名 值        <span class="comment">#判断指定值是否在集合中</span></span><br><span class="line">scard 集合名          <span class="comment">#获取集合中的元素个数</span></span><br><span class="line">srem 集合名 值1 [值2 <span class="string">...</span>]    <span class="comment">#移除集合中的一个或多个指定元素</span></span><br><span class="line"></span><br><span class="line">srandmember 集合名    [数值]    <span class="comment">#随机抽取一个或指定数值个数的元素</span></span><br><span class="line">spop 集合名 [数值]            <span class="comment">#随机移除一个或指定数值个数的元素</span></span><br><span class="line">smove 集合名1 集合名2 值       <span class="comment">#将指定值从集合1移动到集合2中</span></span><br><span class="line"></span><br><span class="line">sdiff 集合名1 集合名2    [集合名3 <span class="string">...</span>]  <span class="comment">#获取集合1有而集合2没有的元素（差集）</span></span><br><span class="line">sinter 集合名1 集合名2 [集合名3 <span class="string">...</span>]    <span class="comment">#获取集合1、2都有的元素（交集）</span></span><br><span class="line">sunion 集合名1 集合名2 [集合名3 <span class="string">...</span>]    <span class="comment">#获取集合1、2中所有的元素（并集）</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound03.md-10.png"></p><p><img data-src="/images/redis-expound03.md-11.png"></p><p><img data-src="/images/redis-expound03.md-12.png"></p><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Hash 中存的也是键值对，只不过它的值是 Map 集合。就是像这样子的：Key -<code>&lt;Key-Value&gt;</code>。本质和 String 类型没有太大区别。（为了易于区分，Hash 中的键在下面就叫做哈希）</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hset 哈希名 键1 值1 [键2 值2 <span class="string">...</span>]        <span class="comment">#将一个或多个键值对添加到哈希中（能够直接覆盖存在键的值）</span></span><br><span class="line">hget 哈希名 键                         <span class="comment">#获取哈希中键相应的值</span></span><br><span class="line">hmset 哈希名 键1 值1 [键2 值2 <span class="string">...</span>]        <span class="comment">#将一个或多个键值对添加到哈希中（能够直接覆盖存在键的值）</span></span><br><span class="line">hmget 哈希名 键1 [键2 <span class="string">...</span>]             <span class="comment">#获取哈希中一个或多个键相应的值</span></span><br><span class="line">hgetall 哈希名                          <span class="comment">#获取全部的数据</span></span><br><span class="line"></span><br><span class="line">hdel 哈希名 键1 [键2 <span class="string">...</span>]             <span class="comment">#移除哈希中的一个或多个键值对</span></span><br><span class="line">hlen 哈希名                          <span class="comment">#获取哈希中的键数量</span></span><br><span class="line">hexists 哈希名 键                     <span class="comment">#判断哈希中指定键是否存在</span></span><br><span class="line"></span><br><span class="line">hkeys 哈希名                           <span class="comment">#获取哈希中所有的键</span></span><br><span class="line">hvals 哈希名                            <span class="comment">#获取哈希中所有的值</span></span><br><span class="line">hincrby 哈希名 键 数值                <span class="comment">#指定哈希值增量</span></span><br><span class="line">hsetnx 哈希名 键 值                     <span class="comment">#哈希中如果键不存在就创建</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound03.md-13.png"></p><p><img data-src="/images/redis-expound03.md-14.png"></p><p><img data-src="/images/redis-expound03.md-15.png"></p><h3 id="备注：-1"><a href="#备注：-1" class="headerlink" title="备注："></a>备注：</h3><p>哈希适合存储经常变动的信息，特别是对象的存储。</p><h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zadd 有序集合名 分数1 元素1 [分数2 元素2 <span class="string">...</span>]        <span class="comment">#添加一个或多个带分数的元素到有序集合中（能够直接覆盖存在元素的分数）</span></span><br><span class="line"><span class="comment">#下面命令中的 withscores 表示的是连同分数一起显示出来。并且下面命令中的数值1一定要大于数值2。</span></span><br><span class="line">zrange 有序集合名 数值1 数值2 [withscores]           <span class="comment">#闭区间截取有序集合，并且是按分数升序进行排序。</span></span><br><span class="line">zrevrange 有序集合名 数值1 数值2    [withscores]       <span class="comment">#闭区间截取有序集合，并且是按分数降序进行排序。</span></span><br><span class="line">zrangebyscore 有序集合名 数值1 数值2    [withscores]    <span class="comment">#闭区间截取有序集合，并且按照分数从数值1到数值2进行排序。数值1可以是 -inf，数值2可以是 +inf。</span></span><br><span class="line"></span><br><span class="line">zrem 有序集合名 元素1 [元素2 <span class="string">...</span>]            <span class="comment">#移除有序集合中一个或多个指定元素</span></span><br><span class="line">zcard 有序集合名                  <span class="comment">#获取有序集合中元素个数</span></span><br><span class="line">zcount 有序集合名 数值1 数值2    <span class="comment">#按分数闭区间获取有序集合中元素个数</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound03.md-16.png"></p><p><img data-src="/images/redis-expound03.md-17.png"></p><h3 id="备注：-2"><a href="#备注：-2" class="headerlink" title="备注："></a>备注：</h3><p>有序集合可用于成绩表或工资表排序。带权重进行判断是普通消息还是重要消息。排行榜实现。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Key-Value（键值对）&quot;&gt;&lt;a href=&quot;#Key-Value（键值对）&quot; class=&quot;headerlink&quot; title=&quot;Key-Value（键值对）&quot;&gt;&lt;/a&gt;Key-Value（键值对）&lt;/h2&gt;&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; 键 值        &lt;span class=&quot;comment&quot;&gt;#设置键值对（能够直接覆盖存在键的值）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt; 键        &lt;span class=&quot;comment&quot;&gt;#获取键相应的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;keys&lt;/span&gt; *         &lt;span class=&quot;comment&quot;&gt;#查看所有键&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exists 键    &lt;span class=&quot;comment&quot;&gt;#判断键是否存在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;move 数据库    &lt;span class=&quot;comment&quot;&gt;#移动键到别的数据库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;expire 键 秒数    &lt;span class=&quot;comment&quot;&gt;#设置键的过期时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ttl 键        &lt;span class=&quot;comment&quot;&gt;#查看键剩余时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;type 键        &lt;span class=&quot;comment&quot;&gt;#查看键类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img data-src=&quot;/images/redis-expound03.md-0.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;String（字符串）&quot;&gt;&lt;a href=&quot;#String（字符串）&quot; class=&quot;headerlink&quot; title=&quot;String（字符串）&quot;&gt;&lt;/a&gt;String（字符串）&lt;/h2&gt;&lt;figure class=&quot;highlight jboss-cli&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;append 键 字符串  &lt;span class=&quot;comment&quot;&gt;#追加字符串，如果当前 key 不存在，就相当于设置键值对。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;strlen 键        &lt;span class=&quot;comment&quot;&gt;#获取字符串长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;incr 键            &lt;span class=&quot;comment&quot;&gt;#值加一&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;decr 键            &lt;span class=&quot;comment&quot;&gt;#值减一&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;incrby 键 步长       &lt;span class=&quot;comment&quot;&gt;#指定值增量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;decrby 键 步长       &lt;span class=&quot;comment&quot;&gt;#指定值减量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getrange 键 数值1 数值2     &lt;span class=&quot;comment&quot;&gt;#闭区间截取字符串。当数值2为-1时，表示从数值1的下标开始截取到最后一个值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setrange 键 数值 字符串    &lt;span class=&quot;comment&quot;&gt;#替换为指定位置开始的字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setex 键 秒数 值   &lt;span class=&quot;comment&quot;&gt;#设置键值对，并会在指定秒数后过期。（set with expire）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setnx 键 值        &lt;span class=&quot;comment&quot;&gt;#如果键不存在就创建（分布式锁中经常使用）(set if not exist)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mset 键1 值1 [键2 值2 &lt;span class=&quot;string&quot;&gt;...&lt;/span&gt;]   &lt;span class=&quot;comment&quot;&gt;#设置一个或多个键值对（能够直接覆盖存在键的值）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mget 键1 键2 [键3 &lt;span class=&quot;string&quot;&gt;...&lt;/span&gt;]         &lt;span class=&quot;comment&quot;&gt;#获取一个或多个键相应的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msetnx 键1 值1 [键2 值2 &lt;span class=&quot;string&quot;&gt;...&lt;/span&gt;]        &lt;span class=&quot;comment&quot;&gt;#如果不存在就创建键值对。但是其具有原子性，就是其中一个键存在，其它键就都不会被创建。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getset 键 值        &lt;span class=&quot;comment&quot;&gt;#先获取键相应的值，再设置键相应的值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#对象创建的两种方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; user&lt;span class=&quot;function&quot;&gt;:1&lt;/span&gt; &amp;#123;name&lt;span class=&quot;function&quot;&gt;:guest997&lt;/span&gt;,age&lt;span class=&quot;function&quot;&gt;:18&lt;/span&gt;&amp;#125;  &lt;span class=&quot;comment&quot;&gt;#设置键为 user:1，值为 json 字符。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mset user&lt;span class=&quot;function&quot;&gt;:1&lt;/span&gt;&lt;span class=&quot;function&quot;&gt;:name&lt;/span&gt; guest997 user&lt;span class=&quot;function&quot;&gt;:1&lt;/span&gt;&lt;span class=&quot;function&quot;&gt;:age&lt;/span&gt; 18      &lt;span class=&quot;comment&quot;&gt;#设置两个键分别为 user:1:name 和 user:1:age，值分别为 guest997 和 18。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="redis" scheme="http://guest997.tk/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 详解(二)</title>
    <link href="http://guest997.tk/2021/09/28/redis-expound02/"/>
    <id>http://guest997.tk/2021/09/28/redis-expound02/</id>
    <published>2021-09-28T02:48:22.000Z</published>
    <updated>2021-10-04T04:12:26.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis（Remote-Dictionary-Server）"><a href="#Redis（Remote-Dictionary-Server）" class="headerlink" title="Redis（Remote Dictionary Server）"></a>Redis（Remote Dictionary Server）</h2><p>Redis 是一个开源的使用 C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库。它可以用作数据库、缓存和消息中间件。</p><ul><li>  内存存储、持久化</li><li>  高速缓存</li><li>  发布订阅系统</li><li>  地图信息分析</li><li>  计时器、计数器</li></ul><h2 id="安装并运行测试-Redis"><a href="#安装并运行测试-Redis" class="headerlink" title="安装并运行测试 Redis"></a>安装并运行测试 Redis</h2><p>下载并上传 Redis 压缩包到 Linux 服务器下的 /opt 目录下。（程序一般都放在这）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压压缩包</span></span><br><span class="line"><span class="attribute">tar</span> -zxvf redis-<span class="number">6</span>.<span class="number">2</span>.<span class="number">5</span>.tar.gz</span><br><span class="line"><span class="comment">#基本的环境安装和配置</span></span><br><span class="line"><span class="attribute">yum</span> install gcc-c++</span><br><span class="line"><span class="attribute">make</span></span><br><span class="line"><span class="attribute">make</span> install</span><br></pre></td></tr></table></figure><p>Redis 的默认安装路径：/usr/local/bin，将 /opt/redis-6.2.5/redis.conf 配置文件复制到 /usr/local/bin/myconfig 目录下。以后就使用这个复制过来的配置文件。（主要是为了有个备份，防止误操作）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="regexp">/usr/</span>local<span class="regexp">/bin/my</span>config</span><br><span class="line">cp <span class="regexp">/opt/</span>redis-<span class="number">6.2</span>.<span class="number">5</span><span class="regexp">/redis.conf /u</span>sr<span class="regexp">/local/</span>bin/myconfig</span><br></pre></td></tr></table></figure><p>Redis 默认不是后台启动的，需要修改配置文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/bin/my</span>config</span><br><span class="line">vim redis.conf    <span class="comment">#将 daemonize no 改为 daemonize yes</span></span><br></pre></td></tr></table></figure><p>运行并测试 Redis。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span></span><br><span class="line">redis-server myconfig/redis.conf    <span class="comment">#指定配置文件启动 redis</span></span><br><span class="line">redis-cli -p <span class="number">6379</span>        <span class="comment">#使用 redis 客户端连接</span></span><br><span class="line">ping</span><br><span class="line">shutdown    <span class="comment">#关闭 redis</span></span><br><span class="line"><span class="keyword">exit</span>        <span class="comment">#退出</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound02.md-0.png"></p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#100个并发连接，100000请求。</span></span><br><span class="line"><span class="attribute">redis</span>-benchmark -h localhost -p <span class="number">6379</span> -c <span class="number">100</span> -n <span class="number">100000</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound02.md-1.png"></p><h2 id="基础知识和命令"><a href="#基础知识和命令" class="headerlink" title="基础知识和命令"></a>基础知识和命令</h2><p>redis 默认有16个数据库，配置文件中有这样的一项配置。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">databases</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/redis-expound02.md-2.png"></p><p><strong>Redis 是单线程的。</strong></p><p>Redis 是基于内存操作，CPU 不是 Redis 的性能瓶颈，Redis 的性能瓶颈是机器的内存和网络带宽，既然可以使用单线程就能实现，那就使用单线程就完事了。</p><p><strong>那 Redis 为什么使用的是单线程还这么快？</strong></p><p>Redis 将所有的数据放在内存中，所以说使用单线程去操作效率就是最高的，多线程会涉及到 CPU 上下文会切换，而这是一个耗时的操作，对于内存系统而言，如果没有上下文切换效率就是最高的。多次读写都是在一个 CPU 上，在内存情况下，这个就是最佳的方案。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Redis（Remote-Dictionary-Server）&quot;&gt;&lt;a href=&quot;#Redis（Remote-Dictionary-Server）&quot; class=&quot;headerlink&quot; title=&quot;Redis（Remote Dictionary Server）&quot;&gt;&lt;/a&gt;Redis（Remote Dictionary Server）&lt;/h2&gt;&lt;p&gt;Redis 是一个开源的使用 C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库。它可以用作数据库、缓存和消息中间件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  内存存储、持久化&lt;/li&gt;
&lt;li&gt;  高速缓存&lt;/li&gt;
&lt;li&gt;  发布订阅系统&lt;/li&gt;
&lt;li&gt;  地图信息分析&lt;/li&gt;
&lt;li&gt;  计时器、计数器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装并运行测试-Redis&quot;&gt;&lt;a href=&quot;#安装并运行测试-Redis&quot; class=&quot;headerlink&quot; title=&quot;安装并运行测试 Redis&quot;&gt;&lt;/a&gt;安装并运行测试 Redis&lt;/h2&gt;&lt;p&gt;下载并上传 Redis 压缩包到 Linux 服务器下的 /opt 目录下。（程序一般都放在这）&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="redis" scheme="http://guest997.tk/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 详解(一)</title>
    <link href="http://guest997.tk/2021/09/27/redis-expound01/"/>
    <id>http://guest997.tk/2021/09/27/redis-expound01/</id>
    <published>2021-09-27T01:51:08.000Z</published>
    <updated>2021-10-04T04:12:16.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主从复制-读写分离"><a href="#主从复制-读写分离" class="headerlink" title="主从复制 + 读写分离"></a>主从复制 + 读写分离</h2><p><strong>在使用读写分离之前应该考虑使用缓存能不能解决问题。读写分离主要应对的是数据库读并发。</strong></p><p>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其它的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。<img data-src="/images/redis-expound01.md-0.png"></p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>解决数据库存储压力的答案之一就是分库分表。</p><h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><p>分库就是对单库的数据进行拆分，可以是垂直拆分，也可以是水平拆分。<br>垂直拆分指的是按照业务对数据库中的表进行分组，同组的放到一个新的数据库（逻辑上，并非实例）中。需要从实际业务出发将大业务分割成小业务。<img data-src="/images/redis-expound01.md-1.png"></p><p>在数据库垂直拆分后遇到单机数据库性能瓶颈之后，就可以考虑数据库水平拆分了。之所以先垂直拆分才水平拆分，是因为垂直拆分后数据业务清晰而且单一，更加方便指定水平的标准。<img data-src="/images/redis-expound01.md-2.png"></p><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><p>分表就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。<br>垂直拆分是对数据表列的拆分，把一张列比较多的表拆分为多张表。<img data-src="/images/redis-expound01.md-3.png"></p><p>水平拆分是对数据表行的拆分，把一张行比较多的表拆分为多张表，表结构维持不变。也就是说拆分后数据集的并集等于拆分前的数据集。在这就不再赘述了。</p><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p><strong>随着时代变化，MySQL 等关系型数据库就不够用了，因为数据量很大，变化很快。一些比较大的文件和图片，如果有一种数据库来专门处理这些数据，MySQL 等关系型数据库压力就会变得很小。</strong></p><h2 id="一个基本的互联网项目"><a href="#一个基本的互联网项目" class="headerlink" title="一个基本的互联网项目"></a>一个基本的互联网项目</h2><p><img data-src="/images/redis-expound01.md-4.png"></p><h2 id="NoSQL（Not-Only-SQL）"><a href="#NoSQL（Not-Only-SQL）" class="headerlink" title="NoSQL（Not Only SQL）"></a>NoSQL（Not Only SQL）</h2><p>NoSQL，泛指非关系型的数据库。随着互联网 web2.0 网站的兴起，传统的关系数据库在处理 web2.0 网站，特别是超大规模和高并发的社交网络服务类型的 web2.0 纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。</p><p>特点：</p><ul><li>  方便扩展（因为数据之间没有关系）</li><li>  大数据量高性能（NoSQL 的缓存是记录级的，是一种细粒度的缓存，性能会比较高）</li><li>  数据类型多样（不需要事先设计数据库，随取随用）</li></ul><h2 id="RDBMS-和-NoSQL-的区别"><a href="#RDBMS-和-NoSQL-的区别" class="headerlink" title="RDBMS 和 NoSQL 的区别"></a>RDBMS 和 NoSQL 的区别</h2><p>RDBMS：</p><ul><li>  结构化组织</li><li>  SQL（结构化查询语言）</li><li>  数据和关系存储</li><li>  数据操作和定义语言</li><li>  严格的各种一致性</li><li>  基础的事务操作</li></ul><p>NoSQL：</p><ul><li>  不仅仅是数据</li><li>  没有固定的查询语言</li><li>  键值对存储、列存储、文档存储、图形存储</li><li>  最终一致性</li><li>  CAP 和 BASE 理论</li><li>  高性能、高可用、高可扩</li></ul><h2 id="3V-3高"><a href="#3V-3高" class="headerlink" title="3V + 3高"></a>3V + 3高</h2><p>大数据时代的3V：（主要是描述问题的）</p><ul><li>  海量（Volume）</li><li>  多样（Variety）</li><li>  实时（Velocity）</li></ul><p>互联网需求的3高：（主要是对程序的要求）</p><ul><li>  高并发</li><li>  高可扩</li><li>  高性能</li></ul><h2 id="NoSQL-的四大分类"><a href="#NoSQL-的四大分类" class="headerlink" title="NoSQL 的四大分类"></a>NoSQL 的四大分类</h2><h3 id="KV-键值对数据库"><a href="#KV-键值对数据库" class="headerlink" title="KV 键值对数据库"></a>KV 键值对数据库</h3><ul><li>  Redis</li><li>  Tair</li></ul><h3 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h3><ul><li>  MongoDB：是一个基于分布式文件存储的数据库，主要用来处理大量的文档。MongoDB 是一个介于关系型数据库和非关系型数据库中间的产品。MongoDB 是非关系型数据库中功能最丰富，最像关系型数据库的。</li><li>  ConthDB</li></ul><h3 id="列存储数据库"><a href="#列存储数据库" class="headerlink" title="列存储数据库"></a>列存储数据库</h3><ul><li>  HBase</li><li>  分布式文件系统</li></ul><h3 id="图关系数据库"><a href="#图关系数据库" class="headerlink" title="图关系数据库"></a>图关系数据库</h3><ul><li>  Neo4j</li><li>  InfoGrid</li></ul><h2 id="NoSQL-的四大分类对比"><a href="#NoSQL-的四大分类对比" class="headerlink" title="NoSQL 的四大分类对比"></a>NoSQL 的四大分类对比</h2><p><img data-src="/images/redis-expound01.md-5.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;主从复制-读写分离&quot;&gt;&lt;a href=&quot;#主从复制-读写分离&quot; class=&quot;headerlink&quot; title=&quot;主从复制 + 读写分离&quot;&gt;&lt;/a&gt;主从复制 + 读写分离&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在使用读写分离之前应该考虑使用缓存能不能解决问题。读写分离主要应对的是数据库读并发。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其它的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。&lt;img data-src=&quot;/images/redis-expound01.md-0.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;分库分表&quot;&gt;&lt;a href=&quot;#分库分表&quot; class=&quot;headerlink&quot; title=&quot;分库分表&quot;&gt;&lt;/a&gt;分库分表&lt;/h2&gt;&lt;p&gt;解决数据库存储压力的答案之一就是分库分表。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="redis" scheme="http://guest997.tk/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>blog 从 WordPress 迁移到 Hexo（二）</title>
    <link href="http://guest997.tk/2021/09/21/blog-wordpress-hexo-02/"/>
    <id>http://guest997.tk/2021/09/21/blog-wordpress-hexo-02/</id>
    <published>2021-09-21T07:49:06.000Z</published>
    <updated>2021-10-04T04:07:56.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>使用插件迁移的话，图片会使用 wordpress 的链接，这显然是不符合我们的需求的，有些人可能会使用 cdn，这些倒是没有啥问题，但是如果是把图片存在服务器上的，服务器在的话还好，如果不在了，那这些图片就都全部失效了。所以这里我就讲下图片通过脚本迁移到本地并将文章中的外链进行更换。</p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>在运行下面的脚本前，需要保证所需依赖都安装完成了。具体缺少什么依赖，运行时都会有提示。为了保证能够正常访问到 wordpress 的博客，脚本中设置了本地代理，当然如果能直接正常访问是不需要设置代理的，注释掉即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mimetypes</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> regex</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;http_proxy&quot;</span>] = <span class="string">&quot;http://127.0.0.1:1081&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;https_proxy&quot;</span>] = <span class="string">&quot;http://127.0.0.1:1081&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = <span class="built_in">input</span>(<span class="string">&quot;输入 hexo 的 source 目录&quot;</span>)</span><br><span class="line">    <span class="comment"># 去尾</span></span><br><span class="line">    <span class="keyword">if</span> p.endswith(<span class="string">&quot;\\&quot;</span>):</span><br><span class="line">        p = p[:<span class="built_in">len</span>(p) - <span class="number">1</span>]</span><br><span class="line">    image_p = p + <span class="string">&quot;\\images&quot;</span></span><br><span class="line">    post_p = p + <span class="string">&quot;\\_posts&quot;</span></span><br><span class="line">    <span class="comment"># 查看博文目录是否存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(post_p):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;路径下没_posts路径，请重新输入&quot;</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.chmod(p, <span class="number">777</span>)</span><br><span class="line">    <span class="comment"># 查看图片目录是否存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(image_p):</span><br><span class="line">        os.makedirs(p + <span class="string">&quot;\\images&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.chmod(p, <span class="number">777</span>)</span><br><span class="line">    <span class="comment"># 循环目录下每一个.md 文件</span></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(post_p):</span><br><span class="line">        <span class="keyword">if</span> filename.endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">            <span class="built_in">print</span>(filename)</span><br><span class="line">            path = post_p + <span class="string">&quot;\\&quot;</span> + filename</span><br><span class="line">            <span class="comment"># 以utf8编码读取</span></span><br><span class="line">            f = <span class="built_in">open</span>(path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            content = f.read()</span><br><span class="line">            f.close()</span><br><span class="line">            <span class="comment"># 匹配 markdown 中的图片 即 ![tag](url)</span></span><br><span class="line">            <span class="keyword">for</span> text <span class="keyword">in</span> regex.findall(<span class="string">r&quot;\!\[[^\s]*\]\([a-zA-z]+://[^\s]*\)&quot;</span>, content):</span><br><span class="line">                <span class="built_in">print</span>(text)</span><br><span class="line">                <span class="comment"># 提取 tag 内容</span></span><br><span class="line">                tag = regex.findall(<span class="string">r&quot;\!\[[^\s]*\](?=\([a-zA-z]+://[^\s]*\))&quot;</span>, text)[<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># 提取 url 内容</span></span><br><span class="line">                urldata = regex.findall(<span class="string">r&quot;(?&lt;=\!\[[^\s]*\])\([a-zA-z]+://[^\s]*\)&quot;</span>, text)[<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># 去掉括号</span></span><br><span class="line">                u = urldata[<span class="number">1</span>:<span class="built_in">len</span>(urldata) - <span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 提取当前文章的名字加上编号即为图片名字</span></span><br><span class="line">                name = filename + <span class="string">&quot;-&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">                <span class="comment"># 获取图片</span></span><br><span class="line">                response = requests.get(u)</span><br><span class="line">                <span class="comment"># 取请求头 content-type 属性获取扩展名如.png/.jpg</span></span><br><span class="line">                content_type = response.headers[<span class="string">&#x27;content-type&#x27;</span>]</span><br><span class="line">                extension = mimetypes.guess_extension(content_type)</span><br><span class="line">                <span class="comment"># 请求返回内容</span></span><br><span class="line">                img = response.content</span><br><span class="line">                <span class="comment"># 写入图片文件</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(image_p + <span class="string">&quot;\\&quot;</span> + name + extension, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(img)</span><br><span class="line">                f.close()</span><br><span class="line">                <span class="comment"># 新引用地址</span></span><br><span class="line">                new_u = <span class="string">&quot;/images/&quot;</span> + name + extension</span><br><span class="line">                <span class="comment"># 替换原文</span></span><br><span class="line">                content = content.replace(text, tag + <span class="string">&quot;(&quot;</span> + new_u + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 写入文章文件</span></span><br><span class="line">            f = <span class="built_in">open</span>(path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">            f.write(content)</span><br><span class="line">            f.close()</span><br></pre></td></tr></table></figure><p>运行上面的脚本时会提示输入 hexo 的 source 目录，输入绝对路径即可。迁移到本地的图片会放在 source/images 目录下。<strong>注意：有些图片可能会爬取失败，具体表现为图片格式为 html，这些图片都需要手动下载并进行替换，文章中的链接记得也要替换，不过文章中的图片链接是显示不出来的，这是没问题的，因为将项目 push 到服务器或 Github 上时，项目结构大致如下图所示。文章会自动匹配到域名/images/图片名。</strong></p><p><img data-src="/images/blog-wordpress-hexo-02.md-0.png"></p><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>如有任何疑问，可在下方评论区@我或者发送悄悄话都可以，我会尽力回答。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明：&quot;&gt;&lt;a href=&quot;#说明：&quot; class=&quot;headerlink&quot; title=&quot;说明：&quot;&gt;&lt;/a&gt;说明：&lt;/h2&gt;&lt;p&gt;使用插件迁移的话，图片会使用 wordpress 的链接，这显然是不符合我们的需求的，有些人可能会使用 cdn，这些倒是没有啥问题，但是如果是把图片存在服务器上的，服务器在的话还好，如果不在了，那这些图片就都全部失效了。所以这里我就讲下图片通过脚本迁移到本地并将文章中的外链进行更换。&lt;/p&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;p&gt;在运行下面的脚本前，需要保证所需依赖都安装完成了。具体缺少什么依赖，运行时都会有提示。为了保证能够正常访问到 wordpress 的博客，脚本中设置了本地代理，当然如果能直接正常访问是不需要设置代理的，注释掉即可。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; mimetypes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; regex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; requests&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;os.environ[&lt;span class=&quot;string&quot;&gt;&amp;quot;http_proxy&amp;quot;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&amp;quot;http://127.0.0.1:1081&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;os.environ[&lt;span class=&quot;string&quot;&gt;&amp;quot;https_proxy&amp;quot;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&amp;quot;http://127.0.0.1:1081&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&amp;#x27;__main__&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p = &lt;span class=&quot;built_in&quot;&gt;input&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;输入 hexo 的 source 目录&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 去尾&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; p.endswith(&lt;span class=&quot;string&quot;&gt;&amp;quot;\\&amp;quot;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p = p[:&lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(p) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    image_p = p + &lt;span class=&quot;string&quot;&gt;&amp;quot;\\images&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    post_p = p + &lt;span class=&quot;string&quot;&gt;&amp;quot;\\_posts&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 查看博文目录是否存在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; os.path.exists(post_p):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;路径下没_posts路径，请重新输入&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        exit(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        os.chmod(p, &lt;span class=&quot;number&quot;&gt;777&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 查看图片目录是否存在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; os.path.exists(image_p):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        os.makedirs(p + &lt;span class=&quot;string&quot;&gt;&amp;quot;\\images&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        os.chmod(p, &lt;span class=&quot;number&quot;&gt;777&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 循环目录下每一个.md 文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; filename &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; os.listdir(post_p):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; filename.endswith(&lt;span class=&quot;string&quot;&gt;&amp;quot;.md&amp;quot;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(filename)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            path = post_p + &lt;span class=&quot;string&quot;&gt;&amp;quot;\\&amp;quot;&lt;/span&gt; + filename&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# 以utf8编码读取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            f = &lt;span class=&quot;built_in&quot;&gt;open&lt;/span&gt;(path, &lt;span class=&quot;string&quot;&gt;&amp;quot;r&amp;quot;&lt;/span&gt;, encoding=&lt;span class=&quot;string&quot;&gt;&amp;#x27;utf8&amp;#x27;&lt;/span&gt;, errors=&lt;span class=&quot;string&quot;&gt;&amp;#x27;ignore&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            content = f.read()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            f.close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# 匹配 markdown 中的图片 即 ![tag](url)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; text &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; regex.findall(&lt;span class=&quot;string&quot;&gt;r&amp;quot;\!\[[^\s]*\]\([a-zA-z]+://[^\s]*\)&amp;quot;&lt;/span&gt;, content):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(text)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;# 提取 tag 内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tag = regex.findall(&lt;span class=&quot;string&quot;&gt;r&amp;quot;\!\[[^\s]*\](?=\([a-zA-z]+://[^\s]*\))&amp;quot;&lt;/span&gt;, text)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;# 提取 url 内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                urldata = regex.findall(&lt;span class=&quot;string&quot;&gt;r&amp;quot;(?&amp;lt;=\!\[[^\s]*\])\([a-zA-z]+://[^\s]*\)&amp;quot;&lt;/span&gt;, text)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;# 去掉括号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                u = urldata[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(urldata) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;# 提取当前文章的名字加上编号即为图片名字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                name = filename + &lt;span class=&quot;string&quot;&gt;&amp;quot;-&amp;quot;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;str&lt;/span&gt;(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;# 获取图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                response = requests.get(u)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;# 取请求头 content-type 属性获取扩展名如.png/.jpg&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                content_type = response.headers[&lt;span class=&quot;string&quot;&gt;&amp;#x27;content-type&amp;#x27;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                extension = mimetypes.guess_extension(content_type)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;# 请求返回内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                img = response.content&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;# 写入图片文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;open&lt;/span&gt;(image_p + &lt;span class=&quot;string&quot;&gt;&amp;quot;\\&amp;quot;&lt;/span&gt; + name + extension, &lt;span class=&quot;string&quot;&gt;&amp;#x27;wb&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; f:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    f.write(img)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                f.close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;# 新引用地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                new_u = &lt;span class=&quot;string&quot;&gt;&amp;quot;/images/&amp;quot;&lt;/span&gt; + name + extension&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;# 替换原文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                content = content.replace(text, tag + &lt;span class=&quot;string&quot;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; + new_u + &lt;span class=&quot;string&quot;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# 写入文章文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            f = &lt;span class=&quot;built_in&quot;&gt;open&lt;/span&gt;(path, &lt;span class=&quot;string&quot;&gt;&amp;quot;w&amp;quot;&lt;/span&gt;, encoding=&lt;span class=&quot;string&quot;&gt;&amp;quot;utf8&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            f.write(content)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            f.close()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="建站" scheme="http://guest997.tk/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
    <category term="建站" scheme="http://guest997.tk/tags/%E5%BB%BA%E7%AB%99/"/>
    
    <category term="脚本" scheme="http://guest997.tk/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>blog 从 WordPress 迁移到 Hexo（一）</title>
    <link href="http://guest997.tk/2021/09/20/blog-wordpress-hexo-01/"/>
    <id>http://guest997.tk/2021/09/20/blog-wordpress-hexo-01/</id>
    <published>2021-09-20T02:26:18.000Z</published>
    <updated>2021-10-04T04:07:53.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>hexo 以及 next 主题的安装过程就不赘述了，<strong>注意：next 主题的7和8版本是分开来的，7版本：<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a>，8版本：<a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a>。至于为什么分开来，貌似团队内部的矛盾，而想要安装什么版本，就看你们自己了。（我安装的是8版本）</strong></p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><ul><li>  hexo 目录下运行下面的命令安装迁移插件：</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-migrator-wordpress <span class="comment">--save</span></span><br></pre></td></tr></table></figure><ul><li>  用 wordpress 中自带的导出工具，将所有内容导出。</li></ul><p><img data-src="/images/blog-wordpress-hexo-01.md-0.png"></p><ul><li>  通过下面的命令进行迁移。<strong>注意：迁移并不是完美的迁移，比如页面以及评论是无法迁移过去的，不过它会保留下来，根据自己的需要将生成的 md 文档开头的属性修改即可。</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo migrate wordpress &lt;<span class="built_in">source</span>&gt;     <span class="comment">#source 为 WordPress 导出的文件路径或网址</span></span><br></pre></td></tr></table></figure><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>如有任何疑问，可在下方评论区@我或者发送悄悄话都可以，我会尽力回答。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明：&quot;&gt;&lt;a href=&quot;#说明：&quot; class=&quot;headerlink&quot; title=&quot;说明：&quot;&gt;&lt;/a&gt;说明：&lt;/h2&gt;&lt;p&gt;hexo 以及 next 主题的安装过程就不赘述了，&lt;strong&gt;注意：next 主题的7和8版本是分开来的，7版本：&lt;a href=&quot;https://github.com/theme-next/hexo-theme-next&quot;&gt;https://github.com/theme-next/hexo-theme-next&lt;/a&gt;，8版本：&lt;a href=&quot;https://github.com/next-theme/hexo-theme-next&quot;&gt;https://github.com/next-theme/hexo-theme-next&lt;/a&gt;。至于为什么分开来，貌似团队内部的矛盾，而想要安装什么版本，就看你们自己了。（我安装的是8版本）&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;  hexo 目录下运行下面的命令安装迁移插件：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight ada&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-migrator-wordpress &lt;span class=&quot;comment&quot;&gt;--save&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="建站" scheme="http://guest997.tk/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
    <category term="建站" scheme="http://guest997.tk/tags/%E5%BB%BA%E7%AB%99/"/>
    
    <category term="插件" scheme="http://guest997.tk/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>免费容器 Heroku 搭建 brook 代理</title>
    <link href="http://guest997.tk/2021/09/17/heroku-brook/"/>
    <id>http://guest997.tk/2021/09/17/heroku-brook/</id>
    <published>2021-09-17T01:42:02.000Z</published>
    <updated>2021-10-04T04:10:33.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ol><li> Heroku 为我们提供了免费的容器服务，我们不应该滥用它，所以不宜做为长期翻墙使用。</li><li> Heroku 免费版有所限制，比如：30 分钟无人访问就休眠以及所有实例访问总时长限制为 550 小时。</li></ol><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><ul><li>点击下方链接进入 brook-heroku 项目地址。<br>  <a href="https://github.com/zyp997/brook-heroku">https://github.com/zyp997/brook-heroku</a></li><li>  点击 <strong>Deploy to Heroku</strong> ，进入 Heroku 后台进行部署。</li><li>  只需填入<strong>实例名字</strong>和选择<strong>实例地区</strong>。在下方 <strong>app_name</strong> 项中，填入 <strong>你的实例名字</strong>；<strong>password</strong> 项中，填入密码。</li><li>  点击下方的 <strong>Deploy app</strong> ，等待自动部署完毕。</li><li>  点击 <strong>view</strong> ，会跳到已部署好的实例网站，<strong>如果跳转到了 brook 的官方项目地址或显示502错误，是没问题的。</strong></li><li>  下载支持 Brook 协议的客户端，配置信息如下：</li></ul><p>地址：你的实例名字.herokuapp.com<br>端口：443<br>默认密码：password<br>传输协议：wss<br>默认路径：/ws</p><ul><li>  如果觉得输入配置麻烦，也可以通过下面的地址获取二维码或链接。</li></ul><p>二维码：https://你的实例名字.herokuapp.com:443/密码/qr.png<br>链接： https://你的实例名字.herokuapp.com:443/密码/link.txt</p><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>如有任何疑问，可在下方评论区@我或者发送悄悄话都可以，我会尽力回答。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明：&quot;&gt;&lt;a href=&quot;#说明：&quot; class=&quot;headerlink&quot; title=&quot;说明：&quot;&gt;&lt;/a&gt;说明：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt; Heroku 为我们提供了免费的容器服务，我们不应该滥用它，所以不宜做为长期翻墙使用。&lt;/li&gt;
&lt;li&gt; Heroku 免费版有所限制，比如：30 分钟无人访问就休眠以及所有实例访问总时长限制为 550 小时。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;点击下方链接进入 brook-heroku 项目地址。&lt;br&gt;  &lt;a href=&quot;https://github.com/zyp997/brook-heroku&quot;&gt;https://github.com/zyp997/brook-heroku&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;  点击 &lt;strong&gt;Deploy to Heroku&lt;/strong&gt; ，进入 Heroku 后台进行部署。&lt;/li&gt;
&lt;li&gt;  只需填入&lt;strong&gt;实例名字&lt;/strong&gt;和选择&lt;strong&gt;实例地区&lt;/strong&gt;。在下方 &lt;strong&gt;app_name&lt;/strong&gt; 项中，填入 &lt;strong&gt;你的实例名字&lt;/strong&gt;；&lt;strong&gt;password&lt;/strong&gt; 项中，填入密码。&lt;/li&gt;
&lt;li&gt;  点击下方的 &lt;strong&gt;Deploy app&lt;/strong&gt; ，等待自动部署完毕。&lt;/li&gt;
&lt;li&gt;  点击 &lt;strong&gt;view&lt;/strong&gt; ，会跳到已部署好的实例网站，&lt;strong&gt;如果跳转到了 brook 的官方项目地址或显示502错误，是没问题的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;  下载支持 Brook 协议的客户端，配置信息如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;地址：你的实例名字.herokuapp.com&lt;br&gt;端口：443&lt;br&gt;默认密码：password&lt;br&gt;传输协议：wss&lt;br&gt;默认路径：/ws&lt;/p&gt;</summary>
    
    
    
    <category term="爬墙" scheme="http://guest997.tk/categories/%E7%88%AC%E5%A2%99/"/>
    
    
    <category term="白嫖" scheme="http://guest997.tk/tags/%E7%99%BD%E5%AB%96/"/>
    
    <category term="容器" scheme="http://guest997.tk/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="爬墙" scheme="http://guest997.tk/tags/%E7%88%AC%E5%A2%99/"/>
    
    <category term="heroku" scheme="http://guest997.tk/tags/heroku/"/>
    
  </entry>
  
  <entry>
    <title>免费容器 Heroku 搭建 chisel 代理</title>
    <link href="http://guest997.tk/2021/09/16/heroku-chisel/"/>
    <id>http://guest997.tk/2021/09/16/heroku-chisel/</id>
    <published>2021-09-16T01:44:39.000Z</published>
    <updated>2021-10-04T04:10:35.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ol><li> Heroku 为我们提供了免费的容器服务，我们不应该滥用它，所以不宜做为长期翻墙使用。</li><li> Heroku 免费版有所限制，比如：30 分钟无人访问就休眠以及所有实例访问总时长限制为 550 小时。</li></ol><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><ul><li>点击下方链接进入 chisel-heroku 项目地址。<br>  <a href="https://github.com/zyp997/chisel-heroku">https://github.com/zyp997/chisel-heroku</a></li><li>  点击 <strong>Deploy to Heroku</strong> ，进入 Heroku 后台进行部署。</li><li>  只需填入<strong>实例名字</strong>和选择<strong>实例地区</strong>即可。</li><li>  点击下方的 <strong>Deploy app</strong> ，等待自动部署完毕。</li><li>  点击 <strong>view</strong> ，会跳到已部署好的实例网站，如下图显示即为部署成功。</li></ul><p><img data-src="/images/heroku-chisel.md-0.png"></p><ul><li>  下载 chisel 客户端压缩包，点击下方链接进入官方 github 地址，下载并解压相应系统的压缩包。(也可以到我的网盘下载) <a href="https://github.com/jpillora/chisel/releases">https://github.com/jpillora/chisel/releases</a></li><li>  以 win10 64 位系统进行配置，解压后的文件夹下创建 <strong>startup.bat</strong> 文件，文件内容为：</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\chisel client <span class="params">--keepalive</span> 10s <span class="params">--auth</span> user<span class="function">:pass</span> 你的实例名字<span class="string">.herokuapp.com</span> 1080<span class="function">:socks</span></span><br></pre></td></tr></table></figure><ul><li>  双击运行 <strong>startup.bat</strong> 文件，无红字报错即已经成功运行 chisel。</li><li>  浏览器可以安装 SwitchyOmega 插件设置代理，代理协议设置为 socks5，代理服务器设置为 127.0.0.1，代理端口设置为 1080。（最好配合 gfwlist 进行分流上网）考虑到插件不易下载，故将插件放到了我的网盘的爬墙目录下。（不知道我的网盘地址？左侧栏目就有啊！）</li></ul><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>如有任何疑问，可在下方评论区@我或者发送悄悄话都可以，我会尽力回答。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明：&quot;&gt;&lt;a href=&quot;#说明：&quot; class=&quot;headerlink&quot; title=&quot;说明：&quot;&gt;&lt;/a&gt;说明：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt; Heroku 为我们提供了免费的容器服务，我们不应该滥用它，所以不宜做为长期翻墙使用。&lt;/li&gt;
&lt;li&gt; Heroku 免费版有所限制，比如：30 分钟无人访问就休眠以及所有实例访问总时长限制为 550 小时。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;点击下方链接进入 chisel-heroku 项目地址。&lt;br&gt;  &lt;a href=&quot;https://github.com/zyp997/chisel-heroku&quot;&gt;https://github.com/zyp997/chisel-heroku&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;  点击 &lt;strong&gt;Deploy to Heroku&lt;/strong&gt; ，进入 Heroku 后台进行部署。&lt;/li&gt;
&lt;li&gt;  只需填入&lt;strong&gt;实例名字&lt;/strong&gt;和选择&lt;strong&gt;实例地区&lt;/strong&gt;即可。&lt;/li&gt;
&lt;li&gt;  点击下方的 &lt;strong&gt;Deploy app&lt;/strong&gt; ，等待自动部署完毕。&lt;/li&gt;
&lt;li&gt;  点击 &lt;strong&gt;view&lt;/strong&gt; ，会跳到已部署好的实例网站，如下图显示即为部署成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/heroku-chisel.md-0.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="爬墙" scheme="http://guest997.tk/categories/%E7%88%AC%E5%A2%99/"/>
    
    
    <category term="白嫖" scheme="http://guest997.tk/tags/%E7%99%BD%E5%AB%96/"/>
    
    <category term="容器" scheme="http://guest997.tk/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="爬墙" scheme="http://guest997.tk/tags/%E7%88%AC%E5%A2%99/"/>
    
    <category term="heroku" scheme="http://guest997.tk/tags/heroku/"/>
    
  </entry>
  
  <entry>
    <title>blog 使用的主题——Sakurairo</title>
    <link href="http://guest997.tk/2021/09/15/blog-sakurairo/"/>
    <id>http://guest997.tk/2021/09/15/blog-sakurairo/</id>
    <published>2021-09-15T01:29:51.000Z</published>
    <updated>2021-10-04T04:07:49.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>一个多彩，轻松上手，体验完善，具有强大自定义功能的 WordPress 主题。</p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><h3 id="版本简介："><a href="#版本简介：" class="headerlink" title="版本简介："></a>版本简介：</h3><ul><li>  多语言支持：目前提供简体中文・英语(繁体中文/日本语将在后续版本中实装)</li><li>  自定义度再加强：一言、页尾附加代码、可视化设置，帮助你更好的自定义你的主题。</li><li>  全面进化主题体验：新增追剧模板优化移动端体验、增强的深色模式，更有超过100+处优化改进，主题体验再一次得到加强。</li></ul><h3 id="使用相关："><a href="#使用相关：" class="headerlink" title="使用相关："></a>使用相关：</h3><ul><li>  使用本主题的博客：<a href="https://iro.tw/demo.html">https://iro.tw/demo.html</a></li><li>  主题交流群：<a href="https://jq.qq.com/?_wv=1027&k=U5UJjRik">784229925</a></li><li>  如果在使用过程中遇到了任何问题，请<strong>访问</strong>本主题的 <a href="https://iro.tw/">官方站点</a></li><li>  在确认你遇到的现象确实是一个 Bug 后，请在 <a href="https://github.com/mirai-mamori/Sakurairo/issues/new/choose">Issues</a> 提交问题，并为该问题尽可能的描述清楚， 按照提供的 issue 模板进行填写，谢谢配合。</li></ul><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><h3 id="开源相关："><a href="#开源相关：" class="headerlink" title="开源相关："></a>开源相关：</h3><ul><li>  本主题<strong>基于 <a href="https://github.com/mashirozx/sakura/tree/3.x">Sakura V3 Series</a> 主题进行重构开发</strong>，使用 <a href="https://github.com/mirai-mamori/Sakurairo/blob/master/LICENSE">GPL V2.0</a> 协议开源。</li><li>  本主题使用了部分来自互联网的特效。由于版权及开源协议不明，无法具体说明相关信息。如果本主题使用到您制作的特效，烦请您通过邮件（me#okaeri.org）来取得联系。</li></ul><h3 id="引用相关："><a href="#引用相关：" class="headerlink" title="引用相关："></a>引用相关：</h3><ul><li>  本主题社交网络图标中，流畅设计图标引用于由Paradox设计的 <a href="https://wwi.lanzous.com/ikyq5kgx0wb">Fluent图标包</a></li><li>  本主题社交网络图标中，沐氢图标引用于由缄默设计的 <a href="https://www.coolapk.com/apk/com.muh2.icon">沐氢图标包</a></li><li>  本主题白猫样式Logo参考原主题作者白猫，由 <a href="https://hyacm.com/acai/ui/143/sakura-logo/">Hyacm</a> 提供方案</li><li>  本主题使用 Stevenjoezhang <a href="https://github.com/stevenjoezhang/live2d-widget">Live2d-Widget</a> 作为默认看板娘</li></ul><h3 id="依赖相关："><a href="#依赖相关：" class="headerlink" title="依赖相关："></a>依赖相关：</h3><ul><li>  本主题使用 Fuukei <a href="https://github.com/Fuukei/Public_Repository">Public Repository</a> 作为默认静态资源库</li><li>  本主题使用 Codestar <a href="https://github.com/Codestar/codestar-framework">Codestar Framework</a> 作为设置框架</li><li>  本主题使用 YahnisElsts <a href="https://github.com/YahnisElsts/plugin-update-checker">Plugin Update Checker</a> 以提供主题更新功能</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明：&quot;&gt;&lt;a href=&quot;#说明：&quot; class=&quot;headerlink&quot; title=&quot;说明：&quot;&gt;&lt;/a&gt;说明：&lt;/h2&gt;&lt;p&gt;一个多彩，轻松上手，体验完善，具有强大自定义功能的 WordPress 主题。&lt;/p&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;h3 id=&quot;版本简介：&quot;&gt;&lt;a href=&quot;#版本简介：&quot; class=&quot;headerlink&quot; title=&quot;版本简介：&quot;&gt;&lt;/a&gt;版本简介：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;  多语言支持：目前提供简体中文・英语(繁体中文/日本语将在后续版本中实装)&lt;/li&gt;
&lt;li&gt;  自定义度再加强：一言、页尾附加代码、可视化设置，帮助你更好的自定义你的主题。&lt;/li&gt;
&lt;li&gt;  全面进化主题体验：新增追剧模板优化移动端体验、增强的深色模式，更有超过100+处优化改进，主题体验再一次得到加强。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="建站" scheme="http://guest997.tk/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
    <category term="建站" scheme="http://guest997.tk/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>解锁网易云音乐客户端变灰歌曲（二）</title>
    <link href="http://guest997.tk/2021/09/14/unblockneteasemusic02/"/>
    <id>http://guest997.tk/2021/09/14/unblockneteasemusic02/</id>
    <published>2021-09-14T13:28:43.000Z</published>
    <updated>2021-10-04T04:13:25.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>之前的版本虽然说未失效，但是已经很久没维护了。故在这介绍另一个项目，fork 自 nondanee 的原版，仅作部分优化。</p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>fork 版我实际用起来效果还行，但是会有一些 bug 以及歌曲无法匹配到的问题。搭建方法和之前的文章是一样的，只不过是两个版本的脚本。之前搭建的文章：<a href="https://guest997.ml/practical/unblockneteasemusic/">https://guest997.ml/practical/unblockneteasemusic/</a></p><p>可以保留这两个版本，当使用之前的版本无法匹配到歌曲时，就可以使用现在有人维护的版本。需要注意的是：如果两个版本都使用了一样的代理端口号，就需要把运行中的版本终止掉，然后运行你想要的版本。查看占用端口的程序的 pid 和终止相应的 pid 的程序命令如下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -aonfindstr <span class="string">&quot;端口&quot;</span>       <span class="comment">#查看占用端口的程序的 pid</span></span><br><span class="line">taskkill <span class="regexp">/F /</span>PID pid             <span class="comment">#终止相应的 pid 的程序</span></span><br></pre></td></tr></table></figure><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>fork 版 UnblockNeteaseMusic 项目地址：<a href="https://github.com/UnblockNeteaseMusic/server">https://github.com/UnblockNeteaseMusic/server</a></p><p>如有任何疑问，可在下方评论区@我或者发送悄悄话都可以，我会尽力回答。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;说明：&quot;&gt;&lt;a href=&quot;#说明：&quot; class=&quot;headerlink&quot; title=&quot;说明：&quot;&gt;&lt;/a&gt;说明：&lt;/h2&gt;&lt;p&gt;之前的版本虽然说未失效，但是已经很久没维护了。故在这介绍另一个项目，fork 自 nondanee 的原版，仅作部分优化。&lt;/p&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;p&gt;fork 版我实际用起来效果还行，但是会有一些 bug 以及歌曲无法匹配到的问题。搭建方法和之前的文章是一样的，只不过是两个版本的脚本。之前搭建的文章：&lt;a href=&quot;https://guest997.ml/practical/unblockneteasemusic/&quot;&gt;https://guest997.ml/practical/unblockneteasemusic/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以保留这两个版本，当使用之前的版本无法匹配到歌曲时，就可以使用现在有人维护的版本。需要注意的是：如果两个版本都使用了一样的代理端口号，就需要把运行中的版本终止掉，然后运行你想要的版本。查看占用端口的程序的 pid 和终止相应的 pid 的程序命令如下。&lt;/p&gt;</summary>
    
    
    
    <category term="实用" scheme="http://guest997.tk/categories/%E5%AE%9E%E7%94%A8/"/>
    
    
    <category term="实用" scheme="http://guest997.tk/tags/%E5%AE%9E%E7%94%A8/"/>
    
    <category term="脚本" scheme="http://guest997.tk/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Docker 进阶(三)</title>
    <link href="http://guest997.tk/2021/09/10/docker-advanced03/"/>
    <id>http://guest997.tk/2021/09/10/docker-advanced03/</id>
    <published>2021-09-10T01:40:43.000Z</published>
    <updated>2021-10-04T04:09:16.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><p><img data-src="/images/docker-advanced03.md-0.png"></p><h3 id="容器和宿主机网络"><a href="#容器和宿主机网络" class="headerlink" title="容器和宿主机网络"></a>容器和宿主机网络</h3><p>新建并启动一个容器看下容器的网络地址。然后在宿主机 ping 容器的网络地址。<img data-src="/images/docker-advanced03.md-1.png"></p><p>我们每启动一个 docker 容器，docker 就会给 docker 容器分配一个 ip，使用的是 docker0 的桥接模式，使用的技术是 veth-pair 技术。<img data-src="/images/docker-advanced03.md-2.png"></p><p>veth-pair 就是一对虚拟设备接口，它们都是成对出现的，一端连着协议，一端彼此相连。veth-pair 就是充当一个桥梁，连接各种虚拟网络设备。</p><h3 id="容器间网络"><a href="#容器间网络" class="headerlink" title="容器间网络"></a>容器间网络</h3><p>再新建并启动一个容器 ping 之前创建的容器的网络地址。<img data-src="/images/docker-advanced03.md-3.png"></p><h3 id="网络模型图"><a href="#网络模型图" class="headerlink" title="网络模型图"></a>网络模型图</h3><p><img data-src="/images/docker-advanced03.md-4.jpg"></p><p>tomcat01 和 tomcat02 公用一个路由器 docker0。所有的容器不指定网络的情况下，都是 docker0 路由的，docker 会给容器分配一个默认的可用 ip。</p><p>思考：我们创建一个微服务连接了数据库，使用了 docker0 分配的 ip，服务重启 ip 就会换了，这样就连接不上数据库了。我们希望可以处理这个问题，通过名字来进行容器访问。（<strong>docker0 是不支持容器名连接访问的，（可以自己试一下直接 ping 容器名）所以我们就需要自定义网络</strong>）</p><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><h3 id="查看所有-Docker-网络"><a href="#查看所有-Docker-网络" class="headerlink" title="查看所有 Docker 网络"></a>查看所有 Docker 网络</h3><p><img data-src="/images/docker-advanced03.md-5.png"></p><ul><li>  bridge：桥接（默认，自定义网络就是用的桥接模式）</li><li>  none：不配置网络</li><li>  host：和宿主机共享网络</li><li>  container：容器网络连通（局限很大）</li></ul><h3 id="创建自己的-Docker-网络"><a href="#创建自己的-Docker-网络" class="headerlink" title="创建自己的 Docker 网络"></a>创建自己的 Docker 网络</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#我们之前的容器创建时是有带默认参数的：</span>--<span class="comment">net</span> <span class="comment">bridge，bridge</span> <span class="comment">就是</span> <span class="comment">docker0。</span></span><br><span class="line"><span class="comment">#docker</span> <span class="comment">run</span> <span class="literal">-</span><span class="comment">d</span> <span class="literal">-</span><span class="comment">P</span> --<span class="comment">name</span> <span class="comment">tomcat01</span> <span class="comment">tomcat</span>        <span class="comment">#等价于：docker</span> <span class="comment">run</span> <span class="literal">-</span><span class="comment">d</span> <span class="literal">-</span><span class="comment">P</span> --<span class="comment">net</span> <span class="comment">bridge</span> --<span class="comment">name</span> <span class="comment">tomcat01</span> <span class="comment">tomcat</span></span><br><span class="line"><span class="comment">docker</span> <span class="comment">network</span> <span class="comment">create</span> --<span class="comment">driver</span> <span class="comment">bridge</span> --<span class="comment">subnet</span> <span class="comment">192</span><span class="string">.</span><span class="comment">168</span><span class="string">.</span><span class="comment">0</span><span class="string">.</span><span class="comment">0/16</span> --<span class="comment">gateway</span> <span class="comment">192</span><span class="string">.</span><span class="comment">168</span><span class="string">.</span><span class="comment">0</span><span class="string">.</span><span class="comment">1</span> <span class="comment">mynet</span>    <span class="comment">#自定义网络，subnet：子网掩码，gateway：网关。</span></span><br><span class="line"><span class="comment">docker</span> <span class="comment">network</span> <span class="comment">inspect</span> <span class="comment">mynet</span>    <span class="comment">#查看自定义网络的元数据</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced03.md-6.png"></p><p>新建并启动两个 tomcat 容器使用的是我们刚刚创建的网络，再次查看自定义网络的元数据。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -d -P --net mynet --name tomcat-net01 tomcat</span><br><span class="line">docker <span class="builtin-name">run</span> -d -P --net mynet --name tomcat-net02 tomcat</span><br><span class="line">docker<span class="built_in"> network </span>inspect mynet</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced03.md-7.png"></p><p>测试 tomcat-net01 ping tomcat-net02 能否成功。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> exec -it tomcat-net<span class="number">01</span> ping tomcat-net<span class="number">02</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced03.md-8.png"></p><h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><p>比如 redis 和 mysql 在不同的集群使用不同的网络，就保证了集群是安全和健康的。<img data-src="/images/docker-advanced03.md-9.png"></p><h2 id="不同网段的网络连通"><a href="#不同网段的网络连通" class="headerlink" title="不同网段的网络连通"></a>不同网段的网络连通</h2><p>新建并启动两个 tomcat 容器使用的是默认网络，尝试 ping 我们使用自定义网络的 tomcat。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -d -P --name tomcat-<span class="literal">default</span> tomcat</span><br><span class="line">docker exec -it tomcat-<span class="literal">default</span> <span class="built_in">ping</span> tomcat-net01</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced03.md-10.png"></p><p>尝试连通 tomcat-default 和 tomcat-net01。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network connect mynet tomcat-<span class="keyword">default</span></span><br><span class="line">docker network inspect mynet</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced03.md-11.png"></p><p>连通之后就是将 tomcat-default 放到 mynet 网络下，一个容器两个 ip 地址。（相当于公网 ip 和 内网 ip）</p><p>再次测试 tomcat-default 能否 ping 通 tomcat-net01 和 tomcat-net02。<img data-src="/images/docker-advanced03.md-12.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Docker-网络&quot;&gt;&lt;a href=&quot;#Docker-网络&quot; class=&quot;headerlink&quot; title=&quot;Docker 网络&quot;&gt;&lt;/a&gt;Docker 网络&lt;/h2&gt;&lt;p&gt;&lt;img data-src=&quot;/images/docker-advanced03.md-0.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;容器和宿主机网络&quot;&gt;&lt;a href=&quot;#容器和宿主机网络&quot; class=&quot;headerlink&quot; title=&quot;容器和宿主机网络&quot;&gt;&lt;/a&gt;容器和宿主机网络&lt;/h3&gt;&lt;p&gt;新建并启动一个容器看下容器的网络地址。然后在宿主机 ping 容器的网络地址。&lt;img data-src=&quot;/images/docker-advanced03.md-1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们每启动一个 docker 容器，docker 就会给 docker 容器分配一个 ip，使用的是 docker0 的桥接模式，使用的技术是 veth-pair 技术。&lt;img data-src=&quot;/images/docker-advanced03.md-2.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="docker" scheme="http://guest997.tk/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 进阶(二)</title>
    <link href="http://guest997.tk/2021/09/09/docker-advanced02/"/>
    <id>http://guest997.tk/2021/09/09/docker-advanced02/</id>
    <published>2021-09-09T07:50:18.000Z</published>
    <updated>2021-10-04T04:08:41.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul><li>  每个保留关键字（指令）必须是大写字母。</li><li>  从上到下的执行顺序</li><li>  #表示注释</li><li>  每一个指令都会创建提交一个新的镜像层。</li></ul><h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>                <span class="comment">#基础镜像</span></span><br><span class="line"><span class="keyword">MAINTAINER</span>            <span class="comment">#镜像维护者，一般使用姓名+邮箱。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">                    <span class="comment">#镜像构建时要运行的命令</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash">                    <span class="comment">#将主机上的文件添加到镜像中，支持通过 URL 从远程服务器读取资源并添加到镜像中。</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">                <span class="comment">#镜像工作目录</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash">                <span class="comment">#挂载的目录</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span>                <span class="comment">#端口配置</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash">                    <span class="comment">#容器启动时要运行的命令，可以在容器运行时将该指令指定的命令替代，一个 Dockerfile 仅仅最后一个 CMD 起作用。</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash">            <span class="comment">#容器启动时要运行的命令，可以追加命令。</span></span></span><br><span class="line"><span class="keyword">ONBUILD</span>                <span class="comment">#当我们在一个 Dockerfile 文件中加上 ONBUILD 指令，该指令对利用该 Dockerfile 构建镜像（比如为 A 镜像）不会产生实质性影响。但是当我们编写一个新的 Dockerfile 文件来基于 A 镜像构建一个镜像（比如为 B 镜像）时，这时构造 A 镜像的 Dockerfile 文件中的 ONBUILD 指令就生效了，在构建 B 镜像的过程中，首先会执行 ONBUILD 指令指定的命令，然后才会执行其它指令。需要注意的是，如果是再利用 B 镜像构造新的镜像时，那么 ONBUILD 指令就无效了，也就是说只能在构建子镜像中执行，对孙子镜像构建无效。</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash">                <span class="comment">#类似 ADD 指令，但该指令只能从宿主机上读取资源并添加到镜像中。</span></span></span><br><span class="line"><span class="keyword">ENV</span>                    <span class="comment">#镜像构建时设置环境变量，跟 windows 一样也是键值对的形式。</span></span><br></pre></td></tr></table></figure><h2 id="构建自己的-CentOS"><a href="#构建自己的-CentOS" class="headerlink" title="构建自己的 CentOS"></a>构建自己的 CentOS</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim Dockerfile-centos</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> Guest997&lt;<span class="number">1036635267</span>@qq.com&gt;</span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install vim                <span class="comment">#给原生的 centos 镜像增加 vim</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install net-tools        <span class="comment">#给原生的 centos 镜像增加网络工具</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure><p>编写完了 Dockerfile，就需要构建镜像，并创建和运行容器进行测试了。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile-centos -t mysentos:<span class="number">0.1</span> .        <span class="comment">#构建镜像</span></span><br><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> mycentos:<span class="number">0.1</span>        <span class="comment">#创建和运行容器</span></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">pwd        <span class="comment">#查看当前路径</span></span><br><span class="line">ifconfig</span><br><span class="line">vim test.txt</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced02.md-0.png"></p><h2 id="镜像构建历史"><a href="#镜像构建历史" class="headerlink" title="镜像构建历史"></a>镜像构建历史</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history 镜像名[:TAG]/镜像<span class="built_in">id</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced02.md-1.png"></p><h2 id="CMD-和-ENTRYPOINT-指令区别"><a href="#CMD-和-ENTRYPOINT-指令区别" class="headerlink" title="CMD 和 ENTRYPOINT 指令区别"></a>CMD 和 ENTRYPOINT 指令区别</h2><h3 id="测试-CMD-指令"><a href="#测试-CMD-指令" class="headerlink" title="测试 CMD 指令"></a>测试 CMD 指令</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim Dockerfile-CMD</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> build -f Dockerfile-CMD -t cmdtest:<span class="number">1</span>.<span class="number">0</span> .</span><br><span class="line"><span class="comment">#查看新建并运行容器后控制台输出内容的两者的区别</span></span><br><span class="line"><span class="attribute">docker</span> run cmdtest:<span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">docker</span> run cmdtest:<span class="number">1</span>.<span class="number">0</span> ls -al</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced02.md-2.png"></p><h3 id="测试-ENTRYPOINT-指令"><a href="#测试-ENTRYPOINT-指令" class="headerlink" title="测试 ENTRYPOINT 指令"></a>测试 ENTRYPOINT 指令</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim Dockerfile-ENTRYPOINT</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> build -f Dockerfile-ENTRYPOINT -t entrypointtest:<span class="number">1</span>.<span class="number">0</span> .</span><br><span class="line"><span class="comment">#查看新建并运行容器后控制台输出内容的两者的区别</span></span><br><span class="line"><span class="attribute">docker</span> run entrypointtest:<span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">docker</span> run entrypointtest:<span class="number">1</span>.<span class="number">0</span> -l</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced02.md-3.png"></p><h2 id="构建自己的-Tomcat"><a href="#构建自己的-Tomcat" class="headerlink" title="构建自己的 Tomcat"></a>构建自己的 Tomcat</h2><p>需要准备 tomcat 和 jdk 的压缩包。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim Dockerfile</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER Guest997&lt;<span class="number">1036635267</span>@qq.com&gt;</span><br><span class="line">ADD jdk-<span class="number">8</span>u301-linux-x64.tar.gz <span class="regexp">/usr/</span>local/             <span class="comment">#添加 jdk，ADD 命令会自动解压</span></span><br><span class="line">ADD apache-tomcat-<span class="number">9.0</span>.<span class="number">52</span>.tar.gz <span class="regexp">/usr/</span>local/         <span class="comment">#添加 tomcat，ADD 命令会自动解压</span></span><br><span class="line"></span><br><span class="line">ENV MYPATH <span class="regexp">/usr/</span>local</span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置环境变量，分隔符是:</span></span><br><span class="line">ENV JAVA_HOME <span class="regexp">/usr/</span>local/jdk1.<span class="number">8.0</span>_301</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span><span class="regexp">/lib/</span>dt.jar:<span class="variable">$JAVA_HOME</span><span class="regexp">/lib/</span>tools.jar</span><br><span class="line">ENV CATALINA_HOME <span class="regexp">/usr/</span>local/apache-tomcat-<span class="number">9.0</span>.<span class="number">52</span></span><br><span class="line">ENV CATALINA_BASH <span class="regexp">/usr/</span>local/apache-tomcat-<span class="number">9.0</span>.<span class="number">52</span></span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span><span class="regexp">/bin:$CATALINA_HOME/</span>lib:<span class="variable">$CATALINA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line">EXPOSE <span class="number">8080</span></span><br><span class="line"></span><br><span class="line">CMD <span class="regexp">/usr/</span>local<span class="regexp">/apache-tomcat-9.0.52/</span>bin<span class="regexp">/startup.sh &amp;&amp; tail -F /u</span>sr<span class="regexp">/local/</span>apache-tomcat-<span class="number">9.0</span>.<span class="number">52</span><span class="regexp">/logs/</span>catalina.out</span><br></pre></td></tr></table></figure><p>使用官方命名 <strong>Dockerfile</strong>，build 时不用加 -f 参数，会自动寻找这个文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mytomcat .        <span class="comment">#不指定 tag 就是最新版 latest</span></span><br><span class="line">docker run -d -p <span class="number">9090</span>:<span class="number">8080</span> --name mytomcat -v <span class="regexp">/home/</span>tomcat<span class="regexp">/test:/u</span>sr<span class="regexp">/local/</span>apache-tomcat-<span class="number">9.0</span>.<span class="number">52</span><span class="regexp">/webapps/</span>test -v <span class="regexp">/home/</span>tomcat<span class="regexp">/logs:/u</span>sr<span class="regexp">/local/</span>apache-tomcat-<span class="number">9.0</span>.<span class="number">52</span>/logs mytomcat</span><br><span class="line">curl localhost:<span class="number">9090</span>        <span class="comment">#测试 tomcat 是否启动成功了</span></span><br></pre></td></tr></table></figure><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">#新建 test/WEB-INF/web.xml 文件</span></span><br><span class="line"><span class="xml">cd /home/tomcat/test</span></span><br><span class="line"><span class="xml">mkdir WEB-INF</span></span><br><span class="line"><span class="xml">vim WEB-INF/web.xml</span></span><br><span class="line"><span class="xml"><span class="meta">&lt;?xml version=&quot;3.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">                             http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">         <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span></span><br><span class="line"><span class="xml">#新建 test/index.jsp 文件</span></span><br><span class="line"><span class="xml">vim index.jsp</span></span><br><span class="line"><span class="xml">&lt;%</span><span class="ruby">@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span></span><br><span class="line"><span class="ruby">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span></span><span class="xml">%&gt;</span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>HelloDockerfile<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">Hello World!<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="xml">&lt;%</span><span class="ruby"></span></span><br><span class="line"><span class="ruby">System.out.println(<span class="string">&quot;HelloDockerfile!&quot;</span>);</span></span><br><span class="line"><span class="ruby"></span><span class="xml">%&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>访问 ip:9090/test，就会出现 HelloDockerfile! 字样了。</p><h2 id="发布镜像到-Docker-Hub"><a href="#发布镜像到-Docker-Hub" class="headerlink" title="发布镜像到 Docker Hub"></a>发布镜像到 Docker Hub</h2><p><strong>注意：如果没有镜像名前缀的话默认是 push 到官方的 library，是会 push 失败的。所以要么镜像构建时前缀使用 dockerhub 的用户名，要么就是直接更改镜像 tag。</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login -u 用户名 -p m        <span class="meta">#登录 Docker Hub</span></span><br><span class="line">docker <span class="keyword">push</span> 镜像名[:TAG]</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced02.md-4.png"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><img data-src="/images/docker-advanced02.md-5.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile&quot;&gt;&lt;/a&gt;Dockerfile&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;  每个保留关键字（指令）必须是大写字母。&lt;/li&gt;
&lt;li&gt;  从上到下的执行顺序&lt;/li&gt;
&lt;li&gt;  #表示注释&lt;/li&gt;
&lt;li&gt;  每一个指令都会创建提交一个新的镜像层。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Dockerfile-指令&quot;&gt;&lt;a href=&quot;#Dockerfile-指令&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile 指令&quot;&gt;&lt;/a&gt;Dockerfile 指令&lt;/h2&gt;&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt;                &lt;span class=&quot;comment&quot;&gt;#基础镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;MAINTAINER&lt;/span&gt;            &lt;span class=&quot;comment&quot;&gt;#镜像维护者，一般使用姓名+邮箱。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;#镜像构建时要运行的命令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ADD&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;#将主机上的文件添加到镜像中，支持通过 URL 从远程服务器读取资源并添加到镜像中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;#镜像工作目录&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;VOLUME&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;#挂载的目录&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;EXPOSE&lt;/span&gt;                &lt;span class=&quot;comment&quot;&gt;#端口配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;#容器启动时要运行的命令，可以在容器运行时将该指令指定的命令替代，一个 Dockerfile 仅仅最后一个 CMD 起作用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENTRYPOINT&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;#容器启动时要运行的命令，可以追加命令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ONBUILD&lt;/span&gt;                &lt;span class=&quot;comment&quot;&gt;#当我们在一个 Dockerfile 文件中加上 ONBUILD 指令，该指令对利用该 Dockerfile 构建镜像（比如为 A 镜像）不会产生实质性影响。但是当我们编写一个新的 Dockerfile 文件来基于 A 镜像构建一个镜像（比如为 B 镜像）时，这时构造 A 镜像的 Dockerfile 文件中的 ONBUILD 指令就生效了，在构建 B 镜像的过程中，首先会执行 ONBUILD 指令指定的命令，然后才会执行其它指令。需要注意的是，如果是再利用 B 镜像构造新的镜像时，那么 ONBUILD 指令就无效了，也就是说只能在构建子镜像中执行，对孙子镜像构建无效。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;#类似 ADD 指令，但该指令只能从宿主机上读取资源并添加到镜像中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ENV&lt;/span&gt;                    &lt;span class=&quot;comment&quot;&gt;#镜像构建时设置环境变量，跟 windows 一样也是键值对的形式。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;构建自己的-CentOS&quot;&gt;&lt;a href=&quot;#构建自己的-CentOS&quot; class=&quot;headerlink&quot; title=&quot;构建自己的 CentOS&quot;&gt;&lt;/a&gt;构建自己的 CentOS&lt;/h2&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="docker" scheme="http://guest997.tk/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 进阶(一)</title>
    <link href="http://guest997.tk/2021/09/08/docker-advanced01/"/>
    <id>http://guest997.tk/2021/09/08/docker-advanced01/</id>
    <published>2021-09-08T04:25:27.000Z</published>
    <updated>2021-10-04T04:27:49.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>如果数据都存储在容器中，那么删除容器，数据就会丢失。而我们想要的是数据存储在宿主机上，Docker 容器中产生的数据，能够同步到宿主机上，反之亦可；并且容器之间可以有一个数据共享的技术。这就是数据卷技术，<strong>容器的持久化和同步操作。容器间也是可以数据共享的。</strong>（其实就是目录的挂载）</p><h2 id="容器数据卷（就是数据卷，只不过是为了和下面的数据卷容器区分）"><a href="#容器数据卷（就是数据卷，只不过是为了和下面的数据卷容器区分）" class="headerlink" title="容器数据卷（就是数据卷，只不过是为了和下面的数据卷容器区分）"></a>容器数据卷（就是数据卷，只不过是为了和下面的数据卷容器区分）</h2><p>若需要在宿主机和容器之间共享持续更新的数据，可使用容器数据卷。</p><h3 id="v-使用容器数据卷"><a href="#v-使用容器数据卷" class="headerlink" title="-v 使用容器数据卷"></a>-v 使用容器数据卷</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -v 宿主机目录:容器内目录</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced01.md-0.png"></p><p><img data-src="/images/docker-advanced01.md-1.png"></p><p>测试：进入容器中的 /home 目录下，创建 test.txt 文件。看宿主机上是否也创建了。如果宿主机上也创建了，就将容器停止，将内容写入宿主机的 /home/test/test.txt 文件，保存并退出。启动并进入容器，查看文件内容是否被同步过去了。<img data-src="/images/docker-advanced01.md-2.png"><img data-src="/images/docker-advanced01.md-22.png"></p><h3 id="容器内-MySQL-数据持久化"><a href="#容器内-MySQL-数据持久化" class="headerlink" title="容器内 MySQL 数据持久化"></a>容器内 MySQL 数据持久化</h3><p><strong>注意：创建 MySQL 容器时需要指定密码。这些都在官方镜像介绍下有。</strong><img data-src="/images/docker-advanced01.md-3.png"></p><p>使用 SQLyog 连接容器内数据库，然后创建一个 test 数据库。看下在宿主机上的文件是否同步更新了。<img data-src="/images/docker-advanced01.md-4.png"><img data-src="/images/docker-advanced01.md-44.png"></p><p>最后删除整个 MySQL 容器，看下数据是否还在宿主机上。如果数据还在，就说明实现了容器内 MySQL 数据持久化。<img data-src="/images/docker-advanced01.md-5.png"></p><h3 id="匿名和具名挂载"><a href="#匿名和具名挂载" class="headerlink" title="匿名和具名挂载"></a>匿名和具名挂载</h3><p>docker volume 命令可用于查看容器数据卷的信息。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -v 容器内路径        <span class="comment">#匿名挂载</span></span><br><span class="line">docker <span class="built_in">run</span> -v 卷名:容器内路径        <span class="comment">#具名挂载</span></span><br><span class="line">docker <span class="built_in">run</span> -v 宿主机路径:容器内路径 <span class="comment">#指定路径挂载，使用 docker volume ls 命令是查看不到的。</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced01.md-6.png"></p><p>而使用匿名和具名挂载的方式，容器内目录映射到了宿主机上的哪个位置，可以使用 <strong>docker volume inspect 卷名</strong> 进行查看。<img data-src="/images/docker-advanced01.md-7.png"></p><p><strong>一般都会使用具名挂载，因为使用匿名挂载不方便找到挂载到宿主机上的路径在哪。</strong></p><h4 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v [...<span class="symbol">:</span>]容器内路径<span class="symbol">:ro/rw</span>        <span class="comment">#改变容器内的读写权限</span></span><br></pre></td></tr></table></figure><ul><li>  ro：readonly</li><li>  rw：readwrite</li></ul><p>ro 就说明这个路径只能通过宿主机来操作，容器内部是无法操作的。</p><h3 id="Dockerfile-使用容器数据卷"><a href="#Dockerfile-使用容器数据卷" class="headerlink" title="Dockerfile 使用容器数据卷"></a>Dockerfile 使用容器数据卷</h3><p>Dockerfile 就是用来构建 docker 镜像的构建文件，其实就是命令参数脚本。通过这个脚本可以生成镜像，镜像是一层一层的，脚本自然也就是一个个的命令，每个命令都是一层。更加具体的讲解会在后面的文章中写到。</p><p>出于可移值和分享的考虑，具名和指定路径挂载不能够直接在 Dockerfile 中实现。Dockerfile 中只能使用匿名挂载。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;volume1&quot;</span>,<span class="string">&quot;volume2&quot;</span>]    <span class="comment">#多个挂载容器数据卷名</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> build -f Dockerfile -t guest<span class="number">997</span>/centos:<span class="number">1</span>.<span class="number">0</span> .        #.表示生成在当前目录下</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced01.md-8.png"></p><p>新建并启动测试容器是否挂载成功。再查看挂载到了宿主机的哪个位置。<img data-src="/images/docker-advanced01.md-9.png"><img data-src="/images/docker-advanced01.md-99.png"></p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>若需要在多个容器之间共享持续更新的数据，可使用数据卷容器。数据卷容器也是容器，它提供数据卷以供其他容器挂载到这个容器中。语法如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-<span class="keyword">from</span> 数据卷容器名<span class="regexp">/数据卷容器id 镜像名[:TAG]/</span>镜像id</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>新建并启动三个刚刚写的 guest997/centos 镜像容器，分别是 cs01、cs02 和 cs03，cs02 和 cs03 就使用数据卷容器 cs01。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> run -it -d --name cs<span class="number">01</span> guest<span class="number">997</span>/centos:<span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">docker</span> run -it -d --volumes-from cs<span class="number">01</span> --name cs<span class="number">02</span> guest<span class="number">997</span>/centos:<span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">docker</span> run -it -d --volumes-from cs<span class="number">01</span> --name cs<span class="number">03</span> guest<span class="number">997</span>/centos:<span class="number">1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>进入 cs01 中创建 v1/test01.txt 文件，看下是否在 cs02 中同步了，然后在 cs02 中创建test02.txt 文件，看下是否在 cs01 和 cs03 中同步了。然后就是删除数据卷容器 cs01，看下 cs02 中的 v1/test01.txt 和 v1/test02.txt 文件是否还存在。最后就是在 cs02 中创建 v1/test03.txt 文件，看下是否在 cs03 中依旧同步了。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">docker attach cs01</span><br><span class="line">touch <span class="regexp">/v1/</span>test01.txt</span><br><span class="line">ctrl + p + q        <span class="comment">#退出但不停止 cs01</span></span><br><span class="line"></span><br><span class="line">docker attach cs02</span><br><span class="line">ls /v1        <span class="comment">#看下 test01.txt 是否在 cs02 中同步了</span></span><br><span class="line">touch <span class="regexp">/v1/</span>test02.txt</span><br><span class="line">ctrl + p + q        <span class="comment">#退出但不停止 cs02</span></span><br><span class="line"></span><br><span class="line">docker attach cs03</span><br><span class="line">ls /v1        <span class="comment">#看下 test02.txt 是否在 cs03 中同步了</span></span><br><span class="line">ctrl + p + q        <span class="comment">#退出但不停止 cs03</span></span><br><span class="line"></span><br><span class="line">docker attach cs01</span><br><span class="line">ls /v1        <span class="comment">#看下 test02.txt 是否在 cs01 中同步了</span></span><br><span class="line"><span class="keyword">exit</span>    <span class="comment">#退出并停止 cs01</span></span><br><span class="line">docker rm cs01    <span class="comment">#删除 cs01</span></span><br><span class="line"></span><br><span class="line">docker attach cs02</span><br><span class="line">ls /v1        <span class="comment">#看下 test01.txt 和 test02.txt 是否还存在</span></span><br><span class="line">touch <span class="regexp">/v1/</span>test03.txt</span><br><span class="line"><span class="keyword">exit</span>        <span class="comment">#退出并停止 cs02</span></span><br><span class="line"></span><br><span class="line">docker attach cs03</span><br><span class="line">ls /v1        <span class="comment">#看下 test03.txt 是否在 cs03 中依旧同步了。</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-advanced01.md-10.png"></p><p><strong>可以从图中得出结论：数据卷容器实现的数据“共享”，并不只有数据共享，而是更高一层的数据“双向拷贝”。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据卷&quot;&gt;&lt;a href=&quot;#数据卷&quot; class=&quot;headerlink&quot; title=&quot;数据卷&quot;&gt;&lt;/a&gt;数据卷&lt;/h2&gt;&lt;p&gt;如果数据都存储在容器中，那么删除容器，数据就会丢失。而我们想要的是数据存储在宿主机上，Docker 容器中产生的数据，能够同步到宿主机上，反之亦可；并且容器之间可以有一个数据共享的技术。这就是数据卷技术，&lt;strong&gt;容器的持久化和同步操作。容器间也是可以数据共享的。&lt;/strong&gt;（其实就是目录的挂载）&lt;/p&gt;
&lt;h2 id=&quot;容器数据卷（就是数据卷，只不过是为了和下面的数据卷容器区分）&quot;&gt;&lt;a href=&quot;#容器数据卷（就是数据卷，只不过是为了和下面的数据卷容器区分）&quot; class=&quot;headerlink&quot; title=&quot;容器数据卷（就是数据卷，只不过是为了和下面的数据卷容器区分）&quot;&gt;&lt;/a&gt;容器数据卷（就是数据卷，只不过是为了和下面的数据卷容器区分）&lt;/h2&gt;&lt;p&gt;若需要在宿主机和容器之间共享持续更新的数据，可使用容器数据卷。&lt;/p&gt;
&lt;h3 id=&quot;v-使用容器数据卷&quot;&gt;&lt;a href=&quot;#v-使用容器数据卷&quot; class=&quot;headerlink&quot; title=&quot;-v 使用容器数据卷&quot;&gt;&lt;/a&gt;-v 使用容器数据卷&lt;/h3&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="docker" scheme="http://guest997.tk/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基础(四)</title>
    <link href="http://guest997.tk/2021/09/07/docker-basis04/"/>
    <id>http://guest997.tk/2021/09/07/docker-basis04/</id>
    <published>2021-09-07T01:25:25.000Z</published>
    <updated>2021-10-04T04:10:33.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。所有应用，直接打包成 docker 镜像，就可以直接跑起来。</p><h2 id="UnionFs（联合文件系统）"><a href="#UnionFs（联合文件系统）" class="headerlink" title="UnionFs（联合文件系统）"></a>UnionFs（联合文件系统）</h2><p>UnionFs（联合文件系统）：UnionFs 是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层地叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。UnionFs 是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。</p><p><strong>特点：</strong>虽然是一次同时加载多个文件系统，但从外面看来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h2 id="镜像加载原理"><a href="#镜像加载原理" class="headerlink" title="镜像加载原理"></a>镜像加载原理</h2><p>docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是 UnionFS。</p><p>bootfs（boot file system）主要包含 bootloader 和 Kernel，bootloader 主要是引导加载 kernel。Linux 刚启动时会加载 bootfs 文件系统，在 docker 镜像的最底层也是 bootfs，这一层与典型的 Linux/Unix 系统是一样的，包含 boot 加載器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统就会卸载 bootfs。</p><p>rootfs（root file system）在 bootfs 之上。包含的就是典型 Linux 系统中的 /dev、/proc、/bin 和 /etc 等标准目录和文件。 rootfs 就是各种不同的操作系统发行版，比如 Ubuntu 和 CentOS 等等。<img data-src="/images/docker-basis04.md-0.png"></p><p>最直观的效果就是，安装进虚拟机的 CentOS 都是几个G，为什么 Docker 的才几百 M？就是因为对于一个精简的系统，rootfs 可以很小，只需要包含最基本的命令、工具和程序就可以了，底层直接使用的是宿主机的 bootfs。由此可见对于不同的 Liunx 发行版，bootfs 基本上是一致的，因此不同的发行版可以使用公有的 bootfs。</p><h2 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h2><p><strong>为什么 Docker 镜像要采用这种分层的结构呢？</strong></p><p>最大的好处就是资源共享了。比如有多个镜像都从相同的基础镜像构建而来，那么宿主机只需在磁盘上保留一份基础镜像，同时内存中也只需要加载一份基础镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p><p><strong>特点：</strong>Docker 镜像都是只读的，当容器启动时，一个新的可写层会加载到镜像的顶部，这一层就是我们通常说的容器层，容器之下的都叫镜像层。<strong>所有的操作都是基于容器层的。</strong></p><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>用于提交镜像，语法如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit <span class="attribute">-m</span>=<span class="string">&quot;描述信息&quot;</span> <span class="attribute">-a</span>=<span class="string">&quot;作者&quot;</span> 容器名/容器id 目标镜像名:TAG</span><br></pre></td></tr></table></figure><p>我们之前使用的 Tomcat9 镜像是没有项目在 webapps 目录下的，而我们是把 webapp.dist 目录下的 Root 项目直接拷贝放在了 webapps 目录下，才访问到了 Tomcat 的主页。现在我们可以 commit 我们自己修改后的镜像，当使用这个镜像之后，我们就能直接访问到 Tomcat 主页。<img data-src="/images/docker-basis04.md-1.png"></p><p>访问 ip:8080，就会看见 tomcat 的首页了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;镜像&quot;&gt;&lt;a href=&quot;#镜像&quot; class=&quot;headerlink&quot; title=&quot;镜像&quot;&gt;&lt;/a&gt;镜像&lt;/h2&gt;&lt;p&gt;镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。所有应用，直接打包成 docker 镜像，就可以直接跑起来。&lt;/p&gt;
&lt;h2 id=&quot;UnionFs（联合文件系统）&quot;&gt;&lt;a href=&quot;#UnionFs（联合文件系统）&quot; class=&quot;headerlink&quot; title=&quot;UnionFs（联合文件系统）&quot;&gt;&lt;/a&gt;UnionFs（联合文件系统）&lt;/h2&gt;&lt;p&gt;UnionFs（联合文件系统）：UnionFs 是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层地叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。UnionFs 是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;虽然是一次同时加载多个文件系统，但从外面看来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="docker" scheme="http://guest997.tk/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基础(三)</title>
    <link href="http://guest997.tk/2021/09/06/docker-basis03/"/>
    <id>http://guest997.tk/2021/09/06/docker-basis03/</id>
    <published>2021-09-06T07:04:30.000Z</published>
    <updated>2021-10-04T04:10:28.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装并运行测试-Nginx"><a href="#安装并运行测试-Nginx" class="headerlink" title="安装并运行测试 Nginx"></a>安装并运行测试 Nginx</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull nginx</span><br><span class="line"><span class="attribute">docker</span> run -d --name nginx -p <span class="number">1234</span>:<span class="number">80</span> nginx        #容器<span class="number">80</span>端口映射到宿主机<span class="number">1234</span>端口，记得开放宿主机端口。</span><br><span class="line"><span class="attribute">curl</span> localhost:<span class="number">1234</span>        #测试，也可以直接在网页输入：ip:<span class="number">1234</span>，就会看见 nginx 的欢迎页。</span><br><span class="line"><span class="attribute">docker</span> stop nginx        #停止容器</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-basis03.md-0.png"></p><p>我们每次改动 nginx 配置文件，都需要进入容器进行修改，十分的麻烦。想要实现在宿主机提供一个映射路径修改配置文件，容器内就可以自动修改。这会在后面文章的容器数据卷进行讲解。</p><h2 id="安装并运行测试-Tomcat9"><a href="#安装并运行测试-Tomcat9" class="headerlink" title="安装并运行测试 Tomcat9"></a>安装并运行测试 Tomcat9</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker run -it --rm tomcat:9.0      #官方命令是用完即删</span></span><br><span class="line">docker pull tomcat:<span class="number">9.0</span></span><br><span class="line">docker run -d -p <span class="number">1234</span>:<span class="number">8080</span> --name tomcat9 tomcat</span><br><span class="line">curl localhost:<span class="number">1234</span>        <span class="comment">#会发现是404页面，这是因为镜像把不必要的都去掉了，保证最小可运行环境。不过在 webapps.dist 文件夹下还是有 Tomcat 的初始 Root 项目的，我们就把它复制过来放在 webapps 文件夹下。</span></span><br><span class="line">docker exec -it tomcat9 <span class="regexp">/bin/</span>bash</span><br><span class="line">cp -rf webapps.dist/* webapps</span><br><span class="line"><span class="comment">#在网页输入：ip:1234，就会看见 tomcat 的首页。</span></span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line">docker stop tomcat9</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-basis03.md-1.png"></p><p><img data-src="/images/docker-basis03.md-2.png"></p><p>我们以后要部署项目，都要进入容器进行部署，十分的麻烦。想要实现在宿主机提供一个映射路径部署项目，容器内就可以自动部署。这会在后面文章的容器数据卷进行讲解。</p><h2 id="安装并运行测试-elasticsearch"><a href="#安装并运行测试-elasticsearch" class="headerlink" title="安装并运行测试 elasticsearch"></a>安装并运行测试 elasticsearch</h2><p>es 需要暴露的端口很多，并且非常耗内存，这可能会导致启动了 es 容器导致整个服务器卡死。数据一般需要放置到安全目录，这就涉及到了挂载。这些问题都是需要解决的。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> run -d --name elasticsearch -p <span class="number">9200</span>:<span class="number">9200</span> -p <span class="number">9300</span>:<span class="number">9300</span> -e <span class="string">&quot;discovery.type=single-node&quot;</span> elasticsearch:tag        #官方命令，这里就用最新版<span class="number">7</span>.<span class="number">14</span>.<span class="number">0</span>。</span><br><span class="line"><span class="attribute">curl</span> localhost:<span class="number">9200</span></span><br><span class="line"><span class="attribute">docker</span> stats          #查看 docker 容器使用内存情况。</span><br><span class="line"><span class="attribute">docker</span> stop elasticsearch    #测试成功就关掉 elasticSearch，防止因太耗内存而导致服务器卡死。</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-basis03.md-3.png"></p><p><img data-src="/images/docker-basis03.md-4.png"></p><p>可以通过修改环境配置文件实现限制容器内存。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> run -d --name elasticsearch<span class="number">02</span> -p <span class="number">9200</span>:<span class="number">9200</span> -p <span class="number">9300</span>:<span class="number">9300</span> -e <span class="string">&quot;discovery.type=single-node&quot;</span> -e ES_JAVA_OPTS=<span class="string">&quot;-Xms64m -Xmx512m&quot;</span> elasticsearch:tag        #最小使用内存<span class="number">64</span>m，最大使用内存<span class="number">512</span>m。</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-basis03.md-5.png"></p><p>如果要使用 kibana 连接 es，思考网络如何连接？<img data-src="/images/docker-basis03.md-6.png"></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><h3 id="portainer"><a href="#portainer" class="headerlink" title="portainer"></a>portainer</h3><p>Docker 图形化界面管理工具，提供一个后台面板供我们操作。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">8088</span>:<span class="number">9000</span> --restart=always -v <span class="regexp">/var/</span>run<span class="regexp">/docker.sock:/</span>var<span class="regexp">/run/</span>docker.sock --privileged=<span class="keyword">true</span> portainer/portainer</span><br></pre></td></tr></table></figure><p>安装并运行成功后，访问 ip:8088，会出现如下界面需要你创建账户。<img data-src="/images/docker-basis03.md-7.png"></p><p>创建完账户后，选择本地仓库。<img data-src="/images/docker-basis03.md-8.png"></p><p>最后就可以自己捣鼓看一下了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安装并运行测试-Nginx&quot;&gt;&lt;a href=&quot;#安装并运行测试-Nginx&quot; class=&quot;headerlink&quot; title=&quot;安装并运行测试 Nginx&quot;&gt;&lt;/a&gt;安装并运行测试 Nginx&lt;/h2&gt;&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;docker&lt;/span&gt; pull nginx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;docker&lt;/span&gt; run -d --name nginx -p &lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt; nginx        #容器&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;端口映射到宿主机&lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;端口，记得开放宿主机端口。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;curl&lt;/span&gt; localhost:&lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;        #测试，也可以直接在网页输入：ip:&lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;，就会看见 nginx 的欢迎页。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;docker&lt;/span&gt; stop nginx        #停止容器&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img data-src=&quot;/images/docker-basis03.md-0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们每次改动 nginx 配置文件，都需要进入容器进行修改，十分的麻烦。想要实现在宿主机提供一个映射路径修改配置文件，容器内就可以自动修改。这会在后面文章的容器数据卷进行讲解。&lt;/p&gt;
&lt;h2 id=&quot;安装并运行测试-Tomcat9&quot;&gt;&lt;a href=&quot;#安装并运行测试-Tomcat9&quot; class=&quot;headerlink&quot; title=&quot;安装并运行测试 Tomcat9&quot;&gt;&lt;/a&gt;安装并运行测试 Tomcat9&lt;/h2&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="docker" scheme="http://guest997.tk/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基础(二)</title>
    <link href="http://guest997.tk/2021/09/05/docker-basis02/"/>
    <id>http://guest997.tk/2021/09/05/docker-basis02/</id>
    <published>2021-09-05T01:24:01.000Z</published>
    <updated>2021-10-04T04:10:01.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用镜像命令"><a href="#常用镜像命令" class="headerlink" title="常用镜像命令"></a>常用镜像命令</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p>用于查看本机所有镜像，语法如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> images<span class="meta"> [参数]</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>  -a：列出所有镜像</li><li>  -q：只显示镜像 id<img data-src="/images/docker-basis02.md-0.png"></li></ul><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><p>用于搜索镜像，语法如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> search 镜像名<span class="meta"> [参数]</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>  -f：过滤条件<img data-src="/images/docker-basis02.md-1.png"></li></ul><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>用于下载镜像，语法如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名[:<span class="keyword">tag</span>]    <span class="comment">#一般都会指定 tag</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-basis02.md-2.png"></p><p><img data-src="/images/docker-basis02.md-3.png"></p><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><p>用于删除镜像，语法如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [-f] 镜像名[<span class="symbol">:TAG</span>]/镜像id    <span class="comment">#-f：强制删除</span></span><br><span class="line">docker rmi -f <span class="variable">$(</span>docker images -aq)     <span class="comment">#删除全部镜像</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-basis02.md-4.png"></p><h2 id="常用容器命令"><a href="#常用容器命令" class="headerlink" title="常用容器命令"></a>常用容器命令</h2><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p>用于新建并启动容器，语法如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> [参数] 镜像名[:TAG]/镜像<span class="built_in">id</span>        <span class="comment">#不加 TAG，就是使用最新版。</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>  --name 容器名：容器取名</li><li>  -d：后台运行</li><li>  -it /bin/控制台(bash/sh…)：使用交互方式运行，并进入容器。-it 就是为该 docker 创建一个伪终端，这样就可以进入到容器的交互模式，也就是进入到容器里面。/bin/bash 的意思是表示载入容器后运行 bash，容器中必须要保持一个进程的运行，这样做就是为了防止整个容器启动后马上杀死自己。</li><li>  -p：容器端口映射</li><li>  -p ip:宿主机端口:容器端口</li><li>  -p 宿主机端口:容器端口（常用）</li><li>  -p 容器端口</li><li>  容器端口</li><li>  -P：随机指定宿主机和容器端口映射<img data-src="/images/docker-basis02.md-5.png"></li></ul><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>用于查看容器状态，语法如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> ps [参数]    <span class="comment">#不加参数，就表示查看运行中的容器</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>  -a：列出所有容器</li><li>  -q：只显示容器 id<img data-src="/images/docker-basis02.md-6.png"></li></ul><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span>     <span class="comment">#容器停止并退出（能够只使用 -d 参数就能在后台运行的容器就不会停止，因为一般进入容器都是使用控制台进入进行交互的，使用 exit 就直接退出控制台，这样 docker 就会认为容器没事做了，就直接停止了）</span></span><br><span class="line"><span class="comment">#ctrl + P + Q     #容器不停止退出</span></span><br></pre></td></tr></table></figure><h3 id="启动、停止和重启容器"><a href="#启动、停止和重启容器" class="headerlink" title="启动、停止和重启容器"></a>启动、停止和重启容器</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名/容器<span class="built_in">id</span>        <span class="comment">#启动容器</span></span><br><span class="line">docker stop 容器名/容器<span class="built_in">id</span>        <span class="comment">#停止容器</span></span><br><span class="line">docker restart 容器名/容器<span class="built_in">id</span>        <span class="comment">#重启容器</span></span><br><span class="line">docker kill 容器名/容器<span class="built_in">id</span>        <span class="comment">#强制停止容器</span></span><br></pre></td></tr></table></figure><h3 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h3><p>用于删除容器，语法如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> [-<span class="type">f</span>] 容器名/容器id    <span class="comment">#删除容器，-f 表示强制</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="variable">$</span>(docker <span class="built_in">ps</span> <span class="literal">-aq</span>)      <span class="comment">#删除所有的容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-aqxargs</span> docker <span class="built_in">rm</span>      <span class="comment">#删除所有的容器</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-basis02.md-7.png"></p><h2 id="其它常用命令"><a href="#其它常用命令" class="headerlink" title="其它常用命令"></a>其它常用命令</h2><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h3><p>用于查看容器日志，语法如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">log</span> [参数] 容器名/容器<span class="built_in">id</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>  -f：持续打印日志</li><li>  -t：打印时间戳<img data-src="/images/docker-basis02.md-8.png"></li></ul><h3 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a>docker top</h3><p>用于查看容器中的进程信息，语法如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器名/容器<span class="built_in">id</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-basis02.md-9.png"></p><h3 id="docker-inspect（重要）"><a href="#docker-inspect（重要）" class="headerlink" title="docker inspect（重要）"></a>docker inspect（重要）</h3><p>用于查看容器/镜像元数据，语法如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名/容器<span class="built_in">id</span></span><br><span class="line">docker image inspect 镜像名[:TAG]/镜像<span class="built_in">id</span></span><br></pre></td></tr></table></figure><h3 id="进入正在运行的容器"><a href="#进入正在运行的容器" class="headerlink" title="进入正在运行的容器"></a>进入正在运行的容器</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名<span class="regexp">/容器id /</span>bin<span class="regexp">/控制台（bash/</span>sh...）</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-basis02.md-10.png"></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器名/容器<span class="built_in">id</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-basis02.md-11.png"></p><p>区别：</p><ul><li>  docker exec：进入容器后开启一个新的控制台。</li><li>  docker attach：进入容器正在执行的控制台，不会启动新的进程。</li></ul><h3 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h3><p>用于从容器中复制文件到宿主机上，语法如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器名/容器<span class="built_in">id</span>:容器文件路径 宿主机目的路径</span><br></pre></td></tr></table></figure><p><img data-src="/images/docker-basis02.md-12.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;常用镜像命令&quot;&gt;&lt;a href=&quot;#常用镜像命令&quot; class=&quot;headerlink&quot; title=&quot;常用镜像命令&quot;&gt;&lt;/a&gt;常用镜像命令&lt;/h2&gt;&lt;h3 id=&quot;docker-images&quot;&gt;&lt;a href=&quot;#docker-images&quot; class=&quot;headerlink&quot; title=&quot;docker images&quot;&gt;&lt;/a&gt;docker images&lt;/h3&gt;&lt;p&gt;用于查看本机所有镜像，语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;docker&lt;/span&gt; images&lt;span class=&quot;meta&quot;&gt; [参数]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;参数：&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="docker" scheme="http://guest997.tk/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基础(一)</title>
    <link href="http://guest997.tk/2021/09/04/docker-basis01/"/>
    <id>http://guest997.tk/2021/09/04/docker-basis01/</id>
    <published>2021-09-04T02:50:55.000Z</published>
    <updated>2021-10-04T04:30:29.176Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 和虚拟机技术的不同：</p><ul><li>  传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件。</li><li>  容器内的应用直接运行在宿主机的内核中，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了很多。</li><li>  每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响。</li></ul><h2 id="DevOps（开发、运维）"><a href="#DevOps（开发、运维）" class="headerlink" title="DevOps（开发、运维）"></a>DevOps（开发、运维）</h2><p><strong>更快速地交付和部署</strong></p><p>传统：一堆帮助文档，安装程序。<br>Docker：打包镜像发布测试一键运行。</p><p><strong>更便捷地升级和缩/扩容</strong></p><p>升级只需将整个镜像进行升级即可。横向拓展服务器，只需将镜像放到另一台服务器直接运行即可。</p><p><strong>更简单的系统运维</strong></p><p>开发和测试环境高度一致。</p><p><strong>更高效地利用计算资源</strong></p><p>Docker 是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例。服务器的性能可以被利用到极致。</p><h2 id="Docker-基本组成"><a href="#Docker-基本组成" class="headerlink" title="Docker 基本组成"></a>Docker 基本组成</h2><p><img data-src="/images/docker-basis01.md-0.jpg"></p><p><strong>镜像（Images）：</strong></p><p>Docker 镜像就好比是一个模板，可以通过这个模板来创建容器服务，镜像 ==&gt; run ==&gt; 容器（提供服务），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中）。</p><p><strong>容器（container）：</strong><br>Docker 利用容器技术，独立运行一个或者一组应用。</p><p><strong>仓库（repository）：</strong><br>仓库就是存放镜像的地方。仓库分为公有仓库和私有仓库。</p><h2 id="安装并运行测试-Docker"><a href="#安装并运行测试-Docker" class="headerlink" title="安装并运行测试 Docker"></a>安装并运行测试 Docker</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#卸载旧版本</span></span><br><span class="line">yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-engine</span><br><span class="line"></span><br><span class="line"><span class="meta">#yum 安装依赖包</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#设置镜像仓库（默认是国外的，不推荐）</span></span><br><span class="line"><span class="meta">#yum-config-manager \</span></span><br><span class="line"><span class="meta">#--add-repo \</span></span><br><span class="line"><span class="meta">#https://download.docker.com/linux/centos/docker-ce.repo</span></span><br><span class="line"><span class="meta">#推荐使用国内的</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https:<span class="comment">//mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#更新 yum 软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="meta">#安装 docker，docker-ce 是社区版，而 ee 是企业版。</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#启动 docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#查看是否安装并且启动成功</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="meta">#测试</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="meta">#查看镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="docker-run-流程"><a href="#docker-run-流程" class="headerlink" title="docker run 流程"></a>docker run 流程</h2><p><img data-src="/images/docker-basis01.md-1.png"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>Docker 是一个 Client-Server 结构的系统，Docker 的守护进程运行在宿主机上，通过 Socket 从客户端访问。Docker-Server 接收到 Docker-Client 的指令，就会执行这个命令。<img data-src="/images/docker-basis01.md-2.png"></p><h2 id="Docker-比-VM-快的原因"><a href="#Docker-比-VM-快的原因" class="headerlink" title="Docker 比 VM 快的原因"></a>Docker 比 VM 快的原因</h2><p>Docker 有着比虚拟机更少的抽象层。由于 Docker 不需要虚拟机管理程序实现硬件资源虚拟化，运行在 Docker 容器上的程序直接使用的都是实际物理机的硬件资源。因此在 CPU、内存利用率上 Docker 将会在效率上有明显优势。![]/images/docker-basis01.md-3.png)<img data-src="/images/docker-basis01.md-33.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Docker 和虚拟机技术的不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;  传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件。&lt;/li&gt;
&lt;li&gt;  容器内的应用直接运行在宿主机的内核中，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了很多。&lt;/li&gt;
&lt;li&gt;  每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;DevOps（开发、运维）&quot;&gt;&lt;a href=&quot;#DevOps（开发、运维）&quot; class=&quot;headerlink&quot; title=&quot;DevOps（开发、运维）&quot;&gt;&lt;/a&gt;DevOps（开发、运维）&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;更快速地交付和部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传统：一堆帮助文档，安装程序。&lt;br&gt;Docker：打包镜像发布测试一键运行。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="docker" scheme="http://guest997.tk/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux 详解(六)</title>
    <link href="http://guest997.tk/2021/09/03/linux-expound06/"/>
    <id>http://guest997.tk/2021/09/03/linux-expound06/</id>
    <published>2021-09-03T01:43:36.000Z</published>
    <updated>2021-10-04T04:12:01.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防火墙命令"><a href="#防火墙命令" class="headerlink" title="防火墙命令"></a>防火墙命令</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看 firewall 服务状态</span></span><br><span class="line"><span class="string">systemctl</span> <span class="string">status</span> <span class="string">firewalld</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启 firewalld.service 服务</span></span><br><span class="line"><span class="string">service</span> <span class="string">firewalld</span> <span class="string">start</span></span><br><span class="line"><span class="comment">#重启 firewalld.service 服务</span></span><br><span class="line"><span class="string">service</span> <span class="string">firewalld</span> <span class="string">restart</span></span><br><span class="line"><span class="comment">#关闭 firewalld.service 服务</span></span><br><span class="line"><span class="string">service</span> <span class="string">firewalld</span> <span class="string">stop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看防火墙规则</span></span><br><span class="line"><span class="string">firewall-cmd</span> <span class="built_in">--list-all</span>    <span class="comment">#查看全部信息</span></span><br><span class="line"><span class="string">firewall-cmd</span> <span class="built_in">--list-ports</span>  <span class="comment">#只看端口信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启端口完后要重启防火墙</span></span><br><span class="line"><span class="string">firewall-cmd</span> <span class="built_in">--zone=public</span> <span class="built_in">--add-port=8080/tcp</span> <span class="built_in">--permanent</span></span><br><span class="line"><span class="comment">#命令含义：</span></span><br><span class="line"><span class="built_in">--zone</span>     <span class="comment">#作用域</span></span><br><span class="line"><span class="built_in">--add-port=8080/tcp</span>   <span class="comment">#添加端口</span></span><br><span class="line"><span class="built_in">--permanent</span>           <span class="comment">#永久生效，没有此参数重启后会失效。</span></span><br></pre></td></tr></table></figure><h2 id="rpm-安装-JDK"><a href="#rpm-安装-JDK" class="headerlink" title="rpm 安装 JDK"></a>rpm 安装 JDK</h2><p>官网下载 jdk 包时，需要查看系统架构，可以通过下图的命令进行查看。<img data-src="/images/linux-expound06.md-0.png"></p><p>下载完后。上传到一个目录即可，我这边就上传到 home 目录。</p><h3 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h3><p><img data-src="/images/linux-expound06.md-1.png"></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>配置环境变量需要先查看 jdk 版本。<img data-src="/images/linux-expound06.md-2.png"></p><p>然后输入：<strong>vim /etc/profile</strong> 编辑配置文件。添加下面的内容之后保存并退出。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">JAVA_HOME</span>=/usr/java/jdk1.8.0_301-amd64</span><br><span class="line"><span class="attribute">CLASSPATH</span>=%JAVA_HOME%/lib:%JAVA_HOME%/jre/lib</span><br><span class="line"><span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$JAVA_HOME/bin:$JAVA_HOME/jre/bin</span><br><span class="line"><span class="builtin-name">export</span> PATH CLASSPATH JAVA_HOME</span><br></pre></td></tr></table></figure><p>最后输入：<strong>source /etc/profile</strong> 使配置文件生效。</p><h3 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h3><p>IDEA 直接 package 打包成 jar 包上传到服务器上后，输入命令：<strong>java -jar 包名</strong> 就发布完毕了。</p><h2 id="解压缩安装-Tomcat"><a href="#解压缩安装-Tomcat" class="headerlink" title="解压缩安装 Tomcat"></a>解压缩安装 Tomcat</h2><p>同样地将压缩包上传到 home 目录。</p><h3 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h3><p><img data-src="/images/linux-expound06.md-3.png"></p><h3 id="运行-Tomcat"><a href="#运行-Tomcat" class="headerlink" title="运行 Tomcat"></a>运行 Tomcat</h3><p><img data-src="/images/linux-expound06.md-4.png"></p><h2 id="yum-安装-Docker（一定要联网）"><a href="#yum-安装-Docker（一定要联网）" class="headerlink" title="yum 安装 Docker（一定要联网）"></a>yum 安装 Docker（一定要联网）</h2><h3 id="安装-gcc-相关"><a href="#安装-gcc-相关" class="headerlink" title="安装 gcc 相关"></a>安装 gcc 相关</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> gcc</span><br><span class="line">yum -y <span class="keyword">install</span> gcc-c++</span><br></pre></td></tr></table></figure><h3 id="设置存储库"><a href="#设置存储库" class="headerlink" title="设置存储库"></a>设置存储库</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo https:<span class="regexp">//</span>download.docker.com<span class="regexp">/linux/</span>centos/docker-ce.repo</span><br><span class="line">yum-config-manager --add-repo http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/docker-ce/</span>linux<span class="regexp">/centos/</span>docker-ce.repo  <span class="comment">#推荐使用国内镜像</span></span><br></pre></td></tr></table></figure><h3 id="安装-Docker-引擎"><a href="#安装-Docker-引擎" class="headerlink" title="安装 Docker 引擎"></a>安装 Docker 引擎</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io</span><br></pre></td></tr></table></figure><h3 id="启动-Dokcer"><a href="#启动-Dokcer" class="headerlink" title="启动 Dokcer"></a>启动 Dokcer</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">version</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;防火墙命令&quot;&gt;&lt;a href=&quot;#防火墙命令&quot; class=&quot;headerlink&quot; title=&quot;防火墙命令&quot;&gt;&lt;/a&gt;防火墙命令&lt;/h2&gt;&lt;figure class=&quot;highlight dsconfig&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#查看 firewall 服务状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;systemctl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;firewalld&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#开启 firewalld.service 服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;firewalld&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;start&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#重启 firewalld.service 服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;firewalld&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;restart&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#关闭 firewalld.service 服务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;firewalld&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;stop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#查看防火墙规则&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;firewall-cmd&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;--list-all&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;#查看全部信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;firewall-cmd&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;--list-ports&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#只看端口信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#开启端口完后要重启防火墙&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;firewall-cmd&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;--zone=public&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;--add-port=8080/tcp&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;--permanent&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#命令含义：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;--zone&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;#作用域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;--add-port=8080/tcp&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;#添加端口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;--permanent&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;#永久生效，没有此参数重启后会失效。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;rpm-安装-JDK&quot;&gt;&lt;a href=&quot;#rpm-安装-JDK&quot; class=&quot;headerlink&quot; title=&quot;rpm 安装 JDK&quot;&gt;&lt;/a&gt;rpm 安装 JDK&lt;/h2&gt;&lt;p&gt;官网下载 jdk 包时，需要查看系统架构，可以通过下图的命令进行查看。&lt;img data-src=&quot;/images/linux-expound06.md-0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;下载完后。上传到一个目录即可，我这边就上传到 home 目录。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="linux" scheme="http://guest997.tk/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 详解(五)</title>
    <link href="http://guest997.tk/2021/09/03/linux-expound05/"/>
    <id>http://guest997.tk/2021/09/03/linux-expound05/</id>
    <published>2021-09-03T01:37:08.000Z</published>
    <updated>2021-10-04T04:36:20.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看磁盘使用量"><a href="#查看磁盘使用量" class="headerlink" title="查看磁盘使用量"></a>查看磁盘使用量</h2><ul><li>  df：查看文件系统的整体磁盘使用量。</li><li>  du：查看文件和目录磁盘使用量。<img data-src="/images/linux-expound05.md-0.png"><img data-src="/images/linux-expound05.md-00.png"></li></ul><h2 id="磁盘挂载与卸载"><a href="#磁盘挂载与卸载" class="headerlink" title="磁盘挂载与卸载"></a>磁盘挂载与卸载</h2><p>根文件系统之外的其他文件要想能够被访问，都必须通过关联至根文件系统上的某个目录来实现，关联操作即为挂载，目录即为挂载点，解除此关联关系的过程称之为卸载。</p><p>磁盘挂载语法：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mount</span> 挂载文件名 挂载点</span><br></pre></td></tr></table></figure><p>磁盘卸载语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount <span class="selector-attr">[-f]</span> 挂载文件名或挂载点</span><br></pre></td></tr></table></figure><h2 id="查看进程信息"><a href="#查看进程信息" class="headerlink" title="查看进程信息"></a>查看进程信息</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> [参数] [ <span class="keyword">grep</span> 字符串]        # 表示管道符，管道符左边命令的输出会作为管道符右边命令的输入。<span class="keyword">grep</span> 用于符合条件的字符串。</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>  -a：所有运行中进程信息</li><li>  -u：以用户的信息显示进程信息</li><li>  -x：进程参数<img data-src="/images/linux-expound05.md-1.png"></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pstree</span> [参数]        <span class="comment">#进程树</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>  -p：显示父 id</li><li>  -u：显示用户组<img data-src="/images/linux-expound05.md-2.png"></li></ul><h2 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat <span class="selector-attr">[参数]</span> <span class="selector-attr">[ grep 字符串]</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>  -t：仅显示 tcp 相关选项</li><li>  -u：仅显示 udp 相关选项</li><li>  -n：拒绝显示别名，能显示数字的全部转化为数字。</li><li>  -l：仅列出在监听的服务状态</li><li>  -p：显示建立相关链接的程序名<img data-src="/images/linux-expound05.md-3.png"></li></ul><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kill</span> -<span class="number">9</span> &lt;pid&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;查看磁盘使用量&quot;&gt;&lt;a href=&quot;#查看磁盘使用量&quot; class=&quot;headerlink&quot; title=&quot;查看磁盘使用量&quot;&gt;&lt;/a&gt;查看磁盘使用量&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;  df：查看文件系统的整体磁盘使用量。&lt;/li&gt;
&lt;li&gt;  du：查看文件和目录磁盘使用量。&lt;img data-src=&quot;/images/linux-expound05.md-0.png&quot;&gt;&lt;img data-src=&quot;/images/linux-expound05.md-00.png&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;磁盘挂载与卸载&quot;&gt;&lt;a href=&quot;#磁盘挂载与卸载&quot; class=&quot;headerlink&quot; title=&quot;磁盘挂载与卸载&quot;&gt;&lt;/a&gt;磁盘挂载与卸载&lt;/h2&gt;&lt;p&gt;根文件系统之外的其他文件要想能够被访问，都必须通过关联至根文件系统上的某个目录来实现，关联操作即为挂载，目录即为挂载点，解除此关联关系的过程称之为卸载。&lt;/p&gt;
&lt;p&gt;磁盘挂载语法：&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="linux" scheme="http://guest997.tk/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 详解(四)</title>
    <link href="http://guest997.tk/2021/09/02/linux-expound04/"/>
    <id>http://guest997.tk/2021/09/02/linux-expound04/</id>
    <published>2021-09-02T04:43:43.000Z</published>
    <updated>2021-10-04T04:34:29.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><p>账号管理实质就是在 /etc/passwd 文件中编辑各条记录，同时更新其他系统文件如 /etc/shadow、/etc/group 等。</p><h3 id="添加账号"><a href="#添加账号" class="headerlink" title="添加账号"></a>添加账号</h3><p>语法如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">useradd</span> 参数 用户名</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>  -c：指定一段注释性描述。</li><li>  -m：用户目录如不存在则自动建立。</li><li>  -d：指定用户主目录。如果此目录不存在，则同时使用 -m 选项，可以创建主目录。</li><li>  -g： 指定用户所属的用户组。</li><li>  -G：指定用户所属的附加组。</li><li>  -u：指定用户的用户号。<img data-src="/images/linux-expound04.md-0.png"><img data-src="/images/linux-expound04.md-00.png"></li></ul><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>当你在 root 用户下，切换普通用户的命令为：<strong>su 用户名</strong>。从普通用户切换到 root 用户，则使用命令：<strong>sudo su</strong>。<br>在终端输入 exit、logout，可以退回到原来用户。<img data-src="/images/linux-expound04.md-1.png"></p><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><p>用户账号刚创建时没有密码。语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd <span class="selector-attr">[参数]</span> <span class="selector-attr">[用户名]</span>    #当为 root 用户，可以管理指定用户密码。当为普通用户，只能输入 passwd，修改当前用户密码。 </span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>  -l：锁定密码，即禁用账号。</li><li>  -u：密码解锁。</li><li>  -d：密码清空，但是不允许该用户登录。</li></ul><h3 id="修改帐号"><a href="#修改帐号" class="headerlink" title="修改帐号"></a>修改帐号</h3><p>修改账号就是修改用户的有关属性，如用户号、主目录、用户组等。语法如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">usermod</span> 参数 用户名</span><br></pre></td></tr></table></figure><p>参数就跟上面的添加账号时的参数是一样的，就不再赘述了。</p><h3 id="删除帐号"><a href="#删除帐号" class="headerlink" title="删除帐号"></a>删除帐号</h3><p>删除用户账号就是将 /etc/passwd 等系统文件中的该用户记录删除，一般还会删除用户的主目录。语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel <span class="selector-attr">[参数]</span> 用户名</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>  -r：用户主目录跟随记录一起删除。<img data-src="/images/linux-expound04.md-2.png"></li></ul><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p>用户组管理实质就是在 /etc/group 文件中编辑各条记录。由于与账号管理的语法类似，就不过多描述了。</p><h3 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h3><p>参数：</p><ul><li>  -g：指定新用户组的组标识号。<img data-src="/images/linux-expound04.md-3.png"><img data-src="/images/linux-expound04.md-33.png"></li></ul><h3 id="切换用户组"><a href="#切换用户组" class="headerlink" title="切换用户组"></a>切换用户组</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span><span class="type">grp</span> root</span><br></pre></td></tr></table></figure><p>这条命令将当前用户切换到 root 用户组，前提条件是 root 用户组是该用户的主组或附加组。</p><h3 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h3><p>参数：</p><ul><li>  -g：为用户组指定新的组标识号。</li><li>  -n：将用户组的名字改为新名字。</li></ul><h3 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h3><p><img data-src="/images/linux-expound04.md-4.png"></p><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><ul><li>  /etc/passwd：用户名:密码（不可见）:用户标识号:组标识号:注释性描述:主目录:登录 Shell</li><li>  /etc/shadow：登录名:加密密码:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</li><li>  /etc/group：组名:密码:组标识号:组内用户列表</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;账号管理&quot;&gt;&lt;a href=&quot;#账号管理&quot; class=&quot;headerlink&quot; title=&quot;账号管理&quot;&gt;&lt;/a&gt;账号管理&lt;/h2&gt;&lt;p&gt;账号管理实质就是在 /etc/passwd 文件中编辑各条记录，同时更新其他系统文件如 /etc/shadow、/etc/group 等。&lt;/p&gt;
&lt;h3 id=&quot;添加账号&quot;&gt;&lt;a href=&quot;#添加账号&quot; class=&quot;headerlink&quot; title=&quot;添加账号&quot;&gt;&lt;/a&gt;添加账号&lt;/h3&gt;&lt;p&gt;语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;useradd&lt;/span&gt; 参数 用户名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="学习" scheme="http://guest997.tk/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://guest997.tk/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="linux" scheme="http://guest997.tk/tags/linux/"/>
    
  </entry>
  
</feed>
